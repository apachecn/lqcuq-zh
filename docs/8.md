# 6 åˆ©ç”¨å¾®æ³¢è„‰å†²ç ”ç©¶é‡å­ç¡¬ä»¶


å³å°†æ¥ä¸´
--------

ä»¥ä¸‹ä¸»é¢˜ç›®å‰æ­£å¤„äºŽå¼€å‘é˜¶æ®µï¼Œå³å°†è¢«æ·»åŠ åˆ°æœ¬æ•™ç¨‹ä¸­ï¼š

1\. é€€ç›¸å¹²å’Œèƒ½é‡å¼›è±«ï¼šæµ‹é‡T2å’ŒT1

2\. ä¼˜åŒ–å¾®æ³¢è„‰å†²çš„é«˜ä¿çœŸé‡å­æ¯”ç‰¹æ“ä½œ

6.1 ç”¨Qiskit Pulseæ ¡å‡†é‡å­æ¯”ç‰¹
------------------------------

Qiskitæ˜¯ä¸€ä¸ªç”¨äºŽé‡å­è®¡ç®—æœºç¼–ç¨‹çš„å¼€æºæ¡†æž¶\[1\]ã€‚é€šè¿‡Qiskitå¯ä»¥åœ¨é‡å­è®¾å¤‡ä¸Šæž„å»ºã€æ¨¡æ‹Ÿå’Œè¿è¡Œé‡å­å›žè·¯ã€‚

Qiskit
Pulseæä¾›äº†ç”¨äºŽæŒ‡å®šç‹¬ç«‹äºŽç‰¹å®šç¡¬ä»¶å®žçŽ°çš„é€šç”¨é‡å­è®¾å¤‡çš„è„‰å†²ç™»è®°æŽ§åˆ¶ï¼ˆå¦‚ï¼šè¾“å…¥ä¿¡å·çš„è¿žç»­æ—¶é—´åŠ¨æ€æŽ§åˆ¶ï¼‰çš„è¯­è¨€\[2\]ã€‚

åœ¨æœ¬èŠ‚çš„æ•™ç¨‹å°†ä¼šå±•ç¤ºå¦‚ä½•é€šè¿‡Qiskitå’ŒQiskit
Pulseå®žçŽ°å…¸åž‹çš„å•é‡å­æ¯”ç‰¹æ ¡å‡†ä»¥åŠå¯¹è¯•éªŒè¿›è¡Œç‰¹æ€§æè¿°ã€‚é€šå¸¸ï¼Œè¿™äº›æ˜¯åœ¨å°†è®¾å¤‡åˆ¶é€ å¹¶å®‰è£…åˆ°ç³»ç»Ÿä¸­åŽç«‹å³åœ¨å®žéªŒå®¤ä¸­è¿›è¡Œçš„ç¬¬ä¸€è½®å®žéªŒã€‚è¯¥æ¼”ç¤ºå°†ä¼šä»¥å…¸åž‹çš„å­¦æ ¡æ–¹å¼è¿›è¡Œï¼Œå…è®¸æ‚¨å®žéªŒæ€§åœ°æŽ¢ç´¢åŒèƒ½çº§ç³»ç»ŸåŠ¨åŠ›å­¦ï¼ˆtwo-level-system
dynamicï¼‰ã€‚åœ¨æ¼”ç¤ºä¸­æ‰€æ¶‰åŠçš„æ‰€æœ‰è®¡é‡å•ä½å‡ä»¥æ ‡å‡†SIè¿”å›žï¼Œå¦‚ï¼šHzã€secç­‰ç­‰ã€‚

æ¼”ç¤ºä¸­çš„æ¯æ¬¡è¯•éªŒéƒ½ä¼šç»™äºˆæˆ‘ä»¬æœ‰å…³ç³»ç»Ÿçš„æ›´å¤šä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯é€šå¸¸ä¼šç”¨äºŽåŽç»­çš„è¯•éªŒä¸­ã€‚å› æ­¤ï¼Œæ­¤notebookå†…çš„ä»£ç åŸºæœ¬ä¸Šæ˜¯æŒ‰å…ˆåŽé¡ºåºæ‰§è¡Œã€‚

### å†…å®¹

1\. å…¥é—¨æŒ‡å—

2\. ä½¿ç”¨é¢‘çŽ‡æ‰«ææ‰¾å‡ºé‡å­æ¯”ç‰¹çš„é¢‘çŽ‡

3\. æ ¡å‡†ä¸Žä½¿ç”¨$\pi$è„‰å†²

3.1 ä½¿ç”¨Rabiå®žéªŒæ ¡å‡†$\pi$è„‰å†²

3.2 ç¡®å®š0è¿˜æ˜¯1

3.3 ä½¿ç”¨åè½¬æ¢å¤æµ‹é‡$T_{1}$

4\. ç¡®å®šé‡å­æ¯”ç‰¹çš„ç›¸å¹²æ€§

4.1 ä½¿ç”¨Ramseyå®žéªŒç²¾ç¡®æµ‹é‡é‡å­æ¯”ç‰¹çš„é¢‘çŽ‡

4.2 ä½¿ç”¨å“ˆæ©å›žæ³¢ï¼ˆHahn Echoesï¼‰æµ‹é‡$T_{2}$

5\. å‚è€ƒæ–‡çŒ®

### 1. å…¥é—¨æŒ‡å—

é¦–å…ˆå¯¼å…¥å°†ä¼šä½¿ç”¨åˆ°çš„Pythonåº“ã€‚ç”±äºŽæˆ‘ä»¬ä¼šåœ¨æ ¡å‡†å®žéªŒä¸­ä½¿ç”¨çœŸå®žä¸”åŒ…å«å™ªå£°çš„è®¾å¤‡ï¼Œæ‰€ä»¥éœ€è¦ç”¨åˆ°IBMQè´¦æˆ·ä»¥åŠè®¾ç½®ç›¸åº”çš„åŽç«¯ã€‚

> from qiskit.tools.jupyter import \*
>
> from qiskit import IBMQ
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\', group=\'open\',
> project=\'main\')
>
> backend = provider.get_backend(\'ibmq_armonk\')

æˆ‘ä»¬å¯ä»¥é€šè¿‡æ£€æŸ¥åŽç«¯é…ç½®æ¥éªŒè¯æ‰€æ”¯æ’‘çš„è„‰å†²ç‰¹æ€§ã€‚è¿™ä¸€é…ç½®ç»™å‡ºäº†åŽç«¯è®¾ç½®ç»“æž„çš„ä¸€èˆ¬ä¿¡æ¯ã€‚

> backend_config = backend.configuration()
>
> assert backend_config.open_pulse, \"Backend doesn\'t support Pulse\"
>
> ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åŽç«¯é…ç½®ä¸­æ‰¾åˆ°åŽç«¯è„‰å†²çš„å–æ ·æ—¶é—´ã€‚è¿™ä¸€å‚æ•°åœ¨æž„å»ºå’Œæ‰§è¡Œæ ¡å‡†æ—¶éžå¸¸æœ‰ç”¨ã€‚
>
> dt = backend_config.dt
>
> print(f\"Sampling time: {dt\*1e9} ns\") \# The configuration returns
> dt in seconds, so multiply by
>
> \# 1e9 to get nanoseconds

åŽç«¯ä¼šé»˜è®¤ç»™å‡ºå¦‚ä½•ä½¿ç”¨åŽç«¯çš„èµ·å§‹ç‚¹ã€‚å…¶ä¸­å«æœ‰é‡å­æ¯”ç‰¹é¢‘çŽ‡çš„ä¼°è®¡å’Œæ‰®æ¼”åŸºç¡€é‡å­ç®—å­çš„ç¨‹åºã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤å¯¹å…¶è¿›è¡Œè®¿é—®ï¼š

backend_defaults = backend.defaults()

### 2. ä½¿ç”¨é¢‘çŽ‡æ‰«ææ‰¾å‡ºé‡å­æ¯”ç‰¹çš„é¢‘çŽ‡

æˆ‘ä»¬ä»Žæœç´¢é‡å­æ¯”ç‰¹çš„é¢‘çŽ‡å¼€å§‹ã€‚é‡å­ä½çš„é¢‘çŽ‡æ˜¯åŸºæ€$|0\rangle$å’Œæ¿€å‘æ€$|1\rangle$ä¹‹é—´çš„èƒ½é‡å·®ã€‚è¿™ä¸€é¢‘çŽ‡å¯¹äºŽäº§ç”Ÿè„‰å†²è‡³å…³é‡è¦ï¼Œè„‰å†²å¯ä»¥åœ¨é‡å­æ¯”ä¸Šäº§ç”Ÿç‰¹å®šçš„é‡å­ç®—å­------è¿™ä¹Ÿæ˜¯æ ¡å‡†çš„æœ€ç»ˆç›®æ ‡!

åœ¨è¶…å¯¼çš„é‡å­æ¯”ç‰¹ä¸Šé«˜èƒ½çº§æ˜¯å¯ä»¥è¢«å®žçŽ°çš„ï¼Œä½†æ˜¯æˆ‘ä»¬é€šè¿‡åˆ¶é€ éžåç³»ç»Ÿæ¥æŽ§åˆ¶æ¿€å‘çš„è½¬æ¢------æ„ä¸ºï¼šæˆ‘ä»¬é€šè¿‡éš”ç¦»ä¸¤ä¸ªèƒ½çº§çš„é‡å­æ¯”ç‰¹å¹¶å°†æ¯ä¸ªé‡å­æ¯”ç‰¹è§†ä¸ºåŸºç¡€åŒèƒ½çº§ç³»ç»Ÿæ¥å¿½ç•¥å…¶ä¸­çš„é«˜èƒ½æ€ã€‚

åœ¨å…¸åž‹çš„å®žéªŒè®¾ç½®ä¸­ï¼Œé‡å­æ¯”ç‰¹çš„é¢‘çŽ‡å¯ä»¥é€šè¿‡æ‰«æä¸€æ®µé¢‘çŽ‡çš„èŒƒå›´æ‰¾å‡ºå¹¶ä½¿ç”¨ä¸€ç§å«åšç½‘ç»œåˆ†æžä»ªï¼ˆNetwork
Analyerï¼‰çš„å·¥å…·æ¥å¯»æ‰¾è¢«å¸æ”¶çš„è¿¹è±¡ã€‚ä¹‹åŽï¼Œæˆ‘ä»¬å°†ä¼šçœ‹åˆ°å¦‚ä½•ä½¿ç”¨Ramseyè„‰å†²åºåˆ—è¿›è¡Œæ›´åŠ ç²¾ç¡®çš„æµ‹é‡ã€‚\
é¦–å…ˆï¼Œå®šä¹‰ç”¨äºŽåœ¨é‡å­æ¯”ç‰¹ä¸Šæ‰«æçš„é¢‘çŽ‡èŒƒå›´ã€‚ç”±äºŽè¿™ä¸€èŒƒå›´å¯ä»¥æ˜¯ä»»æ„å¤§å°ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨backend_defaultsä¸­å°†è¿™ä¸€èŒƒå›´é™åˆ¶åœ¨é‡å­æ¯”ç‰¹çš„ä¼°è®¡é¢‘çŽ‡40mhzå·¦å³ã€‚

> import numpy as np
>
> \# unit conversion factors -\> all backend properties returned in SI
> (Hz, sec, etc)
>
> GHz = 1.0e9 \# Gigahertz
>
> MHz = 1.0e6 \# Megahertz
>
> us = 1.0e-6 \# Microseconds
>
> ns = 1.0e-9 \# Nanoseconds
>
> \# We will find the qubit frequency for the following qubit.
>
> qubit = 0
>
> \# The sweep will be centered around the estimated qubit frequency.
>
> center_frequency_Hz = backend_defaults.qubit_freq_est\[qubit\] \# The
> default frequency is given in Hz
>
> \# warning: this will change in a future release
>
> print(f\"Qubit {qubit} has an estimated frequency of
> {center_frequency_Hz / GHz} GHz.\")
>
> \# scale factor to remove factors of 10 from the data
>
> scale_factor = 1e-14
>
> \# We will sweep 40 MHz around the estimated frequency
>
> frequency_span_Hz = 40 \* MHz
>
> \# in steps of 1 MHz.
>
> frequency_step_Hz = 1 \* MHz
>
> \# We will sweep 20 MHz above and 20 MHz below the estimated frequency
>
> frequency_min = center_frequency_Hz - frequency_span_Hz / 2
>
> frequency_max = center_frequency_Hz + frequency_span_Hz / 2
>
> \# Construct an np array of the frequencies for our experiment
>
> frequencies_GHz = np.arange(frequency_min / GHz,
>
> frequency_max / GHz,
>
> frequency_step_Hz / GHz)
>
> print(f\"The sweep will go from {frequency_min / GHz} GHz to
> {frequency_max / GHz} GHz \\
>
> in steps of {frequency_step_Hz / MHz} MHz.\")
>
> è¾“å‡ºï¼š
>
> Qubit 0 has an estimated frequency of 4.974449465550582 GHz.
>
> The sweep will go from 4.9544494655505815 GHz to 4.994449465550582 GHz
> in steps of 1.0 MHz.

æŽ¥ä¸‹æ¥å®šä¹‰å°†ä¼šåœ¨å®žéªŒä¸­è¦ç”¨åˆ°çš„è„‰å†²ã€‚æˆ‘ä»¬ä»Žç§°ä¸ºé«˜æ–¯è„‰å†²çš„é©±åŠ¨è„‰å†²å¼€å§‹ã€‚

æ˜¯å¦è¿˜è®°å¾—ä¸Šé—®ä¸­çš„å€¼dtï¼Ÿæ‰€æœ‰è„‰å†²çš„æ—¶é•¿éƒ½ç”¨dtè¡¨ç¤ºã€‚åœ¨ä¸‹ä¸€å•å…ƒä¸­ï¼Œæˆ‘ä»¬ç”¨dtæ¥å®šä¹‰é©±åŠ¨è„‰å†²çš„é•¿åº¦ã€‚

> \# samples need to be multiples of 16
>
> def get_closest_multiple_of_16(num):
>
> return int(num + 8 ) - (int(num + 8 ) % 16)
>
> from qiskit import pulse \# This is where we access all of our Pulse
> features!
>
> from qiskit.pulse import Play
>
> from qiskit.pulse import pulse_lib \# This Pulse module helps us build
> sampled pulses for common pulse shapes
>
> \# Drive pulse parameters (us = microseconds)
>
> drive_sigma_us = 0.075 \# This determines the actual width of the
> gaussian
>
> drive_samples_us = drive_sigma_us\*8 \# This is a truncating
> parameter, because gaussians don\'t have
>
> \# a natural finite length
>
> drive_sigma = get_closest_multiple_of_16(drive_sigma_us \* us /dt) \#
> The width of the gaussian in units of dt
>
> drive_samples = get_closest_multiple_of_16(drive_samples_us \* us /dt)
> \# The truncating parameter in units of dt
>
> drive_amp = 0.3
>
> \# Drive pulse samples
>
> drive_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_amp,
>
> name=\'freq_sweep_excitation_pulse\')

ä¸ºäº†æ­£ç¡®çš„æµ‹é‡é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬éœ€è¦æ ¸å¯¹æµ‹é‡æ˜ å°„ã€‚è¿™æ˜¯ä¸€ç§å¼ºåˆ¶çº¦æŸï¼Œå› ä¸ºå½“å¯¹ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„æµ‹é‡ç»“æŸåŽï¼Œå¯¹å…¶ä»–é‡å­æ¯”ç‰¹çš„æµ‹é‡ä¹ŸåŒæ—¶ç»“æŸã€‚å½“åœ¨Pulseä¸­åˆ›å»ºç¨‹åºæ—¶éœ€è¦å°Šé‡è¿™ä¸€çº¦æŸã€‚è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹é‡å­æ¯”ç‰¹å±žäºŽå“ªä¸€ç»„é‡å­æ¯”ç‰¹ï¼š

> \# Find out which group of qubits need to be acquired with this qubit
>
> meas_map_idx = None
>
> for i, measure_group in enumerate(backend_config.meas_map):
>
> if qubit in measure_group:
>
> meas_map_idx = i
>
> break
>
> assert meas_map_idx is not None, f\"Couldn\'t find qubit {qubit} in
> the meas_map!\"

çŽ°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰æµ‹é‡è„‰å†²äº†ã€‚ä¸Žå…¶ç¡¬ç¼–ç è„‰å†²ç¨‹åºï¼Œä¸å¦‚ç›´æŽ¥ä»ŽQiskitåŽç«¯çš„é»˜è®¤æŒ‡ä»¤è¡¨ä¸­è°ƒå–ä¸€ä¸ªå·²æ ¡å‡†çš„æµ‹é‡è„‰å†²ã€‚å› ä¸ºè¿™æ ·çš„è„‰å†²ç»å¸¸è¢«æ ¡å‡†ï¼Œè€Œä¸”æ¯”æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„æµ‹é‡è„‰å†²æ›´åŠ ç²¾ç¡®ã€‚å¹¶ä¸”è¿™æ ·çš„æµ‹é‡è„‰å†²åŒ…å«æ•èŽ·ï¼Œå¦‚æ­¤æˆ‘ä»¬å°±æ— é¡»æ‰‹å·¥å®šä¹‰äº†ã€‚

> inst_sched_map = backend_defaults.instruction_schedule_map
>
> measure = inst_sched_map.get(\'measure\',
> qubits=backend_config.meas_map\[meas_map_idx\])

æŽ¥ç€ï¼ŒæŒ‡å®šæ–½åŠ è„‰å†²çš„ä¿¡é“ã€‚é©±åŠ¨ã€æµ‹é‡å’Œæ•èŽ·ä¿¡é“ç”±é‡å­æ¯”ç‰¹çš„é¡ºåºå®šä¹‰ã€‚

> \#\#\# Collect the necessary channels
>
> drive_chan = pulse.DriveChannel(qubit)
>
> meas_chan = pulse.MeasureChannel(qubit)
>
> acq_chan = pulse.AcquireChannel(qubit)

è‡³æ­¤è„‰å†²çš„å‚æ•°å®šä¹‰å®Œæˆï¼Œè€Œä¸”è¿˜ä¸ºå®žéªŒåˆ›å»ºäº†è„‰å†²æ³¢å½¢ï¼ŒæŽ¥ç€æˆ‘ä»¬å°±å¯ä»¥åˆ›å»ºè„‰å†²è°ƒåº¦äº†ã€‚

åœ¨æ¯ä¸€é¢‘çŽ‡ä¸Šï¼Œæˆ‘ä»¬å°†ä¼šå‘é‡å­æ¯”ç‰¹ä¼ é€ä¸€ä¸ªè¯¥é¢‘çŽ‡çš„é©±åŠ¨è„‰å†²å¹¶åœ¨è„‰å†²ä¹‹åŽé©¬ä¸Šæµ‹é‡ã€‚è„‰å†²åŒ…ä¸Žé¢‘çŽ‡æ— å…³ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªå¯é‡ç”¨çš„è°ƒåº¦ï¼ˆscheduleï¼‰ï¼Œå¹¶é€šè¿‡é¢‘çŽ‡æ•°ç»„æ¥æŒ‡å®šé©±åŠ¨è„‰å†²çš„é¢‘çŽ‡ã€‚

> \# Create the base schedule
>
> \# Start with drive pulse acting on the drive channel
>
> schedule = pulse.Schedule(name=\'Frequency sweep\')
>
> schedule += Play(drive_pulse, drive_chan)
>
> \# The left shift \`\<\<\` is special syntax meaning to shift the
> start time of the schedule by some duration
>
> schedule += measure \<\< schedule.duration
>
> \# Create the frequency settings for the sweep (MUST BE IN HZ)
>
> frequencies_Hz = frequencies_GHz\*GHz
>
> schedule_frequencies = \[{drive_chan: freq} for freq in
> frequencies_Hz\]

å¯¹è„‰å†²è°ƒåº¦è¿›è¡Œæ£€æŸ¥æ˜¯æ˜Žæ™ºçš„ä¸¾åŠ¨ï¼Œä½¿ç”¨schedule.draw()å®Œæˆï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

> schedule.draw(label=True)
>
> æ•°ç»„ï¼š

![](pics/media/image331.png)

æˆ‘ä»¬å°†ä¸Šé¢çš„scheduleå’Œschedule_frequenciesç»„åˆæˆä¸€ä¸ªå¯ä»¥å‘é€åˆ°é‡å­è®¾å¤‡ç¨‹åºå¯¹è±¡Qobjã€‚æˆ‘ä»¬åœ¨å…¶ä¸­è¯·æ±‚å¯¹æ¯ä¸ªè°ƒåº¦ï¼ˆé¢‘çŽ‡æ‰«æä¸­çš„æ¯ä¸ªç‚¹ï¼‰é‡å¤num_shots_per_frequencyæ¬¡ï¼Œä»¥èŽ·å¾—å¯¹é‡å­æ¯”ç‰¹å“åº”çš„è‰¯å¥½ä¼°è®¡ã€‚

æˆ‘ä»¬è¿˜æŒ‡å®šäº†æµ‹é‡è®¾ç½®ã€‚meas_level=0è¿”å›žåŽŸå§‹æ•°æ®ï¼ˆæ¯ä¸ªæ¬¡æµ‹é‡è¿”å›žä¸€ä¸ªå¤æ•°å€¼çš„æ•°ç»„ï¼‰ï¼Œmeas_level=1è¿”å›žæ ¸å¿ƒæ•°æ®ï¼ˆæ¯æ¬¡æµ‹é‡è¿”å›žä¸€ä¸ªå¤æ•°å€¼ï¼‰ï¼Œè€Œmeas_level=2è¿”å›žåˆ†ç±»æ•°æ®ï¼ˆæ¯æ¬¡æµ‹é‡è¿”å›žæ¯”ç‰¹0æˆ–æ¯”ç‰¹1ï¼‰ã€‚å¦‚æžœæˆ‘ä»¬è¿˜æ²¡æœ‰å·²æ ¡å‡†çš„é‰´åˆ«å™¨æ¥åŒºåˆ†0å’Œ1çš„è¯ï¼Œå¯ä»¥é€šè¿‡æŒ‡å®šmeas_level=1æ¥å¤åˆ¶åœ¨å®žéªŒå®¤é‡Œè¦ä½¿ç”¨çš„ä¸œè¥¿ã€‚æˆ‘ä»¬æƒ³è¦çš„ç»“æžœæ˜¯"avgï¼ˆå¹³å‡å€¼ï¼‰"è€Œéžæ¯ä¸€æ¬¡çš„æµ‹é‡å€¼ã€‚

> from qiskit import assemble
>
> num_shots_per_frequency = 1024
>
> frequency_sweep_program = assemble(schedule,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_frequency,
>
> schedule_los=schedule_frequencies)

æ‚¨å¯èƒ½ä¼šçœ‹åˆ°å¦ä¸€ä¸ªè®¡é‡å•ä½æ›´æ”¹è­¦å‘Šï¼Œæˆ‘ä»¬å¯ä»¥å®‰å…¨åœ°å¿½ç•¥è¯¥è­¦å‘Šã€‚æœ€åŽï¼Œæˆ‘ä»¬å¯ä»¥åœ¨åŽç«¯ä¸Šè¿è¡Œè¯¥ç»„åˆç¨‹åºï¼š

job = backend.run(frequency_sweep_program)

æ­¤å¤„æœ‰ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼šå°†æœ€åŽæ£€ç´¢çš„job_idæ‰“å°å‡ºæ¥ï¼Œå¹¶é€šè¿‡job_monitor()ç›‘æŽ§ä½œä¸šçš„çŠ¶æ€ã€‚

> \# print(job.job_id())
>
> from qiskit.tools.monitor import job_monitor
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run

ä¸€æ—¦ä½œä¸šå¼€å§‹è¿è¡Œï¼Œç»“æžœå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„ä»£ç å¯¹å…¶æ£€ç´¢ï¼š

> frequency_sweep_results = job.result(timeout=120) \# timeout parameter
> set to 120 seconds

æˆ‘ä»¬ä¼šé€šè¿‡mateplotlibå°†æ‰€æå–çš„ç»“æžœç»˜åˆ¶æˆå›¾ï¼š

> import matplotlib.pyplot as plt
>
> sweep_values = \[\]
>
> for i in range(len(frequency_sweep_results.results)):
>
> \# Get the results from the ith experiment
>
> res = frequency_sweep_results.get_memory(i)\*scale_factor
>
> \# Get the results for \`qubit\` from this experiment
>
> sweep_values.append(res\[qubit\])
>
> plt.scatter(frequencies_GHz, np.real(sweep_values), color=\'black\')
> \# plot real part of sweep values
>
> plt.xlim(\[min(frequencies_GHz), max(frequencies_GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\")
>
> plt.ylabel(\"Measured signal \[a.u.\]\")
>
> plt.show()

![](pics/media/image332.png)

æ­£å¦‚ä¸Šé¢çš„å›¾å½¢æ‰€ç¤ºï¼Œå³°å€¼å¤„äºŽé‡å­æ¯”ç‰¹é¢‘çŽ‡æ‰€å¯¹åº”çš„ä¸­å¿ƒå¤„ã€‚è¿™äº›ä¿¡å·å±•ç¤ºäº†åŠŸçŽ‡å±•å®½ï¼ˆpower-broadeningï¼‰ï¼Œå³å½“æŽ¥è¿‘ä¸­å¿ƒé¢‘çŽ‡æ—¶æˆ‘ä»¬èƒ½å¤Ÿé©±åŠ¨é‡å­æ¯”ç‰¹è„±ç¦»å…±æŒ¯çš„ä¿¡å·ã€‚ä¸ºäº†å¾—åˆ°å³°å€¼é¢‘çŽ‡çš„å€¼ï¼Œæˆ‘ä»¬å°†æŠŠè¿™äº›å€¼æ‹Ÿåˆåˆ°ä¸€ä¸ªå…¸åž‹æ´›ä¼¦å…¹å½¢çŠ¶çš„å…±æŒ¯å“åº”æ›²çº¿ä¸Šã€‚

> from scipy.optimize import curve_fit
>
> def fit_function(x_values, y_values, function, init_params):
>
> fitparams, conv = curve_fit(function, x_values, y_values, init_params)
>
> y_fit = function(x_values, \*fitparams)
>
> return fitparams, y_fit
>
> fit_params, y_fit = fit_function(frequencies_GHz,
>
> np.real(sweep_values),
>
> lambda x, A, q_freq, B, C: (A / np.pi) \* (B / ((x - q_freq)\*\*2 +
> B\*\*2)) + C,
>
> \[5, 4.975, 1, 3\] \# initial parameters for curve_fit
>
> )
>
> plt.scatter(frequencies_GHz, np.real(sweep_values), color=\'black\')
>
> plt.plot(frequencies_GHz, y_fit, color=\'red\')
>
> plt.xlim(\[min(frequencies_GHz), max(frequencies_GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\")
>
> plt.ylabel(\"Measured Signal \[a.u.\]\")
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image333.png)

> A, rough_qubit_frequency, B, C = fit_params
>
> rough_qubit_frequency = rough_qubit_frequency\*GHz \# make sure qubit
> freq is in Hz
>
> print(f\"We\'ve updated our qubit frequency estimate from \"
>
> f\"{round(backend_defaults.qubit_freq_est\[qubit\] / GHz, 5)} GHz to
> {round(rough_qubit_frequency/GHz, 5)} GHz.\")
>
> è¾“å‡ºï¼š
>
> We\'ve updated our qubit frequency estimate from 4.97444 GHz to
> 4.97467 GHz.

### 3. æ ¡å‡†ä¸Žä½¿ç”¨$\mathbf{\pi}$è„‰å†²

#### 3.1 ä½¿ç”¨Rabiå®žéªŒæ ¡å‡†$\mathbf{\pi}$è„‰å†²

å½“æˆ‘ä»¬çŸ¥é“é‡å­æ¯”ç‰¹çš„é¢‘çŽ‡ä¹‹åŽï¼Œä¸‹ä¸€æ­¥å°±æ˜¯ç¡®å®š$\pi$è„‰å†²çš„å¼ºåº¦ã€‚å°†é‡å­æ¯”ç‰¹çœ‹ä½œåŒèƒ½çº§ç³»ç»Ÿæ—¶ï¼Œä¸¥æ ¼åœ°è®²ä¸€ä¸ª$\pi$è„‰å†²ä½œç”¨å°±æ˜¯æŠŠé‡å­æ¯”ç‰¹çš„çŠ¶æ€ä»Ž$|0\rangle$è½¬æ¢ä¸º$\left| 1 \right\rangle$ï¼Œåä¹‹äº¦ç„¶ã€‚$\pi$è„‰å†²ä¹Ÿç§°ä¸º$X$æˆ–$X180$é—¨ï¼Œæˆ–ä½ç¿»è½¬ç®—å­ã€‚æˆ‘ä»¬å·²ç»ä»Žä¸Šé¢çš„é¢‘çŽ‡æ‰«é¢‘å®žéªŒä¸­çŸ¥é“äº†é©±åŠ¨è¿™ç§è½¬å˜æ‰€éœ€çš„å¾®æ³¢é¢‘çŽ‡ï¼ŒçŽ°åœ¨å¯»æ‰¾å®žçŽ°ä»Žæ€$|0\rangle$åˆ°æ€$|1\rangle$çš„ðœ‹æ—‹è½¬æ‰€éœ€æŒ¯å¹…ã€‚æ‰€éœ€çš„æ—‹è½¬åœ¨å¸ƒæ´›èµ«çƒä½“ä¸‹å›¾æ‰€ç¤ºï¼Œæ‚¨å¯ä»¥çœ‹åˆ°ðœ‹è„‰å†²å› å…¶åœ¨å¸ƒæ´›èµ«çƒä¸­æ‰«è¿‡çš„è§’åº¦è€Œå¾—åã€‚

![](pics/media/image334.png)

æˆ‘ä»¬å°†ä¼šé€šè¿‡å°å¹…åº¦çš„å¢žåŠ æ¥æ”¹å˜é©±åŠ¨å¹…å€¼å¹¶åœ¨æ¯æ¬¡æ”¹åŠ¨åŽæµ‹é‡é‡å­æ¯”ç‰¹çš„çŠ¶æ€ã€‚æˆ‘ä»¬æœŸæœ›èƒ½å¤Ÿçœ‹åˆ°é€šå¸¸ç§°ä¸ºRabiæŒ¯åŠ¨çš„æŒ¯åŠ¨ï¼Œå¦‚åŒé‡å­æ¯”ç‰¹ä»Žæ€$|0\rangle$å˜ä¸ºæ€$|1\rangle$ï¼Œç„¶åŽå†å˜å›žæ€$|0\rangle$ã€‚

> \# This experiment uses these values from the previous experiment:
>
> \# \`qubit\`,
>
> \# \`measure\`, and
>
> \# \`rough_qubit_frequency\`.
>
> \# Rabi experiment parameters
>
> num_rabi_points = 50
>
> \# Drive amplitude values to iterate over: 50 amplitudes evenly spaced
> from 0 to 0.75
>
> drive_amp_min = 0
>
> drive_amp_max = 0.75
>
> drive_amps = np.linspace(drive_amp_min, drive_amp_max,
> num_rabi_points)
>
> \# Build the Rabi experiments:
>
> \# A drive pulse at the qubit frequency, followed by a measurement,
>
> \# where we vary the drive amplitude each time.
>
> rabi_schedules = \[\]
>
> for drive_amp in drive_amps:
>
> rabi_pulse = pulse_lib.gaussian(duration=drive_samples, amp=drive_amp,
>
> sigma=drive_sigma, name=f\"Rabi drive amplitude = {drive_amp}\")
>
> this_schedule = pulse.Schedule(name=f\"Rabi drive amplitude =
> {drive_amp}\")
>
> this_schedule += Play(rabi_pulse, drive_chan)
>
> \# Reuse the measure instruction from the frequency sweep experiment
>
> this_schedule += measure \<\< this_schedule.duration
>
> rabi_schedules.append(this_schedule)

ä¸Šé¢ä»£ç æ‰€å®šä¹‰çš„è°ƒåº¦æœ¬è´¨ä¸Šä¸Žé¢‘çŽ‡æ‰«æå®žéªŒç›¸åŒã€‚å…¶å”¯ä¸€çš„åŒºåˆ«æ˜¯ç›¸å¯¹äºŽè°ƒåˆ¶é¢‘çŽ‡è¿™ä¸€æ¬¡æˆ‘ä»¬æ‰€è¿è¡Œçš„æ˜¯å…·æœ‰ä¸åŒé©±åŠ¨è„‰å†²å¹…å€¼çš„ä¸€ç»„å®žéªŒã€‚

> rabi_schedules\[-1\].draw(label=True)
>
> è¾“å‡ºï¼š

![](pics/media/image335.png)

> \# Assemble the schedules into a Qobj
>
> num_shots_per_point = 1024
>
> rabi_experiment_program = assemble(rabi_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_point,
>
> schedule_los=\[{drive_chan: rough_qubit_frequency}\]
>
> \* num_rabi_points)
>
> \# print(job.job_id())
>
> job = backend.run(rabi_experiment_program)
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> rabi_results = job.result(timeout=120)

è‡³æ­¤å°±å¾—åˆ°äº†ç»“æžœï¼Œæˆ‘ä»¬å°†ä¼šæå–å¹¶æ‹Ÿåˆè¿™äº›ç»“æžœè‡³ä¸€ä¸ªæ­£å¼¦æ›²çº¿ã€‚å¯¹äºŽæ‰€é€‰çš„é©±åŠ¨å¹…å€¼çš„èŒƒå›´ï¼Œæˆ‘ä»¬å¸Œæœ›ä»Žæ€$|0\rangle$å¼€å§‹å›´ç»•å¸ƒæ´›èµ«çƒå®Œå…¨æ—‹è½¬é‡å­æ¯”ç‰¹å¤šæ¬¡ã€‚è¿™ç§æ­£å¼¦æ³¢çš„å¹…å€¼å‘Šè¯‰æˆ‘ä»¬è„‰å†²æ¬¡æ•°ä¸­çš„ä¸€å°éƒ¨åˆ†çš„Rabié©±åŠ¨å¹…å€¼ä¼šç”Ÿæˆæ€$|1\rangle$ã€‚æˆ‘ä»¬æƒ³è¦æ‰¾å‡ºä½¿å¾—ä¿¡å·ä»Žæœ€å¤§ï¼ˆæ‰€æœ‰é‡å­æ¯”ç‰¹çš„çŠ¶æ€ä¸º$|0\rangle$ï¼‰åˆ°æœ€å°ï¼ˆæ‰€æœ‰çš„é‡å­æ¯”ç‰¹çŠ¶æ€ä¸º$|1\rangle$ï¼‰çš„æŒ¯è¡æ‰€éœ€çš„é©±åŠ¨å¹…å€¼------è¿™ä¸€è¿‡ç¨‹ç»™å‡ºäº†æ‰®æ¼”ðœ‹è„‰å†²çš„å·²æ ¡å‡†å¹…å€¼ã€‚

> \# center data around 0
>
> def baseline_remove(values):
>
> return np.array(values) - np.mean(values)
>
> rabi_values = \[\]
>
> for i in range(num_rabi_points):
>
> \# Get the results for \`qubit\` from the ith experiment
>
> rabi_values.append(rabi_results.get_memory(i)\[qubit\]\*scale_factor)
>
> rabi_values = np.real(baseline_remove(rabi_values))
>
> plt.xlabel(\"Drive amp \[a.u.\]\")
>
> plt.ylabel(\"Measured signal \[a.u.\]\")
>
> plt.scatter(drive_amps, rabi_values, color=\'black\') \# plot real
> part of Rabi values
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image336.png)

> fit_params, y_fit = fit_function(drive_amps,
>
> rabi_values,
>
> lambda x, A, B, drive_period, phi: (A\*np.cos(2\*np.pi\*x/drive_period
> - phi) + B),
>
> \[3, 0.1, 0.5, 0\])
>
> plt.scatter(drive_amps, rabi_values, color=\'black\')
>
> plt.plot(drive_amps, y_fit, color=\'red\')
>
> drive_period = fit_params\[2\] \# get period of rabi oscillation
>
> plt.axvline(drive_period/2, color=\'red\', linestyle=\'\--\')
>
> plt.axvline(drive_period, color=\'red\', linestyle=\'\--\')
>
> plt.annotate(\"\", xy=(drive_period, 0), xytext=(drive_period/2,0),
> arrowprops=dict(arrowstyle=\"\<-\>\", color=\'red\'))
>
> plt.annotate(\"\$\\pi\$\", xy=(drive_period/2-0.03, 0.1),
> color=\'red\')
>
> plt.xlabel(\"Drive amp \[a.u.\]\", fontsize=15)
>
> plt.ylabel(\"Measured signal \[a.u.\]\", fontsize=15)
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image337.png)

> pi_amp = abs(drive_period / 2)
>
> print(f\"Pi Amplitude = {pi_amp}\")
>
> è¾“å‡ºï¼š
>
> Pi Amplitude = 0.23772202140312107

##### $\mathbf{\pi}$è„‰å†²

çŽ°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨åˆšæ‰æ‰¾åˆ°çš„å¹…å€¼å®šä¹‰è„‰å†²äº†ï¼Œå¹¶å¯åœ¨ä¹‹åŽçš„å®žéªŒä¸­ä½¿ç”¨ã€‚

> pi_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> amp=pi_amp,
>
> sigma=drive_sigma,
>
> name=\'pi_pulse\')

#### 3.2 ç¡®å®š0è¿˜æ˜¯1

ä¸€æ—¦$\pi$è„‰å†²ç»è¿‡æ ¡å‡†ï¼Œå°±èƒ½ä»¥é«˜æ¦‚çŽ‡åˆ›å»ºæ€$|1\rangle$ã€‚æˆ‘ä»¬é€šè¿‡é‡å¤åˆ¶å¤‡ä»¥åŠç»˜åˆ¶æµ‹é‡ä¿¡å·æ¥æ‰¾å‡ºæ€$|0\rangle$å’Œæ€$|1\rangle$åœ¨æµ‹é‡æ—¶æ‰€å‘ˆçŽ°çŠ¶æ€ã€‚è¿™å°±æ˜¯åˆ›å»ºé‰´é¢‘å™¨ï¼ˆdiscriminatorï¼‰çš„è¿‡ç¨‹ï¼Œå…¶ä¸ºæŽ¥å—ä¸€ä¸ªå·²æµ‹é‡çš„æ ¸å¿ƒè´Ÿæ•°ï¼ˆmeas_level=1ï¼‰ä»¥åŠå°†å…¶åˆ†ç±»ä¸º0æˆ–1ï¼ˆmeas_level=2ï¼‰çš„ç®€å•å‡½æ•°ã€‚

> \# Create two schedules
>
> \# Ground state schedule
>
> gnd_schedule = pulse.Schedule(name=\"ground state\")
>
> gnd_schedule += measure
>
> \# Excited state schedule
>
> exc_schedule = pulse.Schedule(name=\"excited state\")
>
> exc_schedule += Play(pi_pulse, drive_chan) \# We found this in Part 2A
> above
>
> exc_schedule += measure \<\< exc_schedule.duration
>
> gnd_schedule.draw(label=True)
>
> è¾“å‡ºï¼š

![](pics/media/image338.png)

> exc_schedule.draw(label=True)
>
> è¾“å‡ºï¼š

![](pics/media/image339.png)

æˆ‘ä»¬å°†åŸºæ€å’Œæ¿€å‘æ€å‡†å¤‡è°ƒåº¦æ±‡æ€»åˆ°ä¸€ä¸ªQobjä¸­ã€‚å…¶ä¸­çš„æ¯ä¸€ä¸ªéƒ½è¦è¿è¡Œnum_shotsæ¬¡ã€‚åœ¨æœ¬æ¬¡å®žéªŒä¸­æˆ‘ä»¬è®¾ç½®å‚æ•°meas_level=1ï¼Œå› ä¸ºæ— éœ€å·²åˆ†ç±»ä¸ºæ€$\left| 0 \right\rangle$å’Œæ€$|1\rangle$çš„ç»“æžœã€‚ç›¸åæœ¬æ¬¡å®žéªŒæˆ‘ä»¬æƒ³è¦æ ¸å¿ƒæ•°æ®ï¼šæ‰€é‡‡é›†çš„åŽŸå§‹æ•°æ®å·²é€šè¿‡æ ¸å‡½æ•°æ¯æ¬¡éƒ½ç”Ÿæˆå•ä¸€å¤æ•°å€¼ã€‚æ‚¨å¯ä»¥å°†æ ¸å‡½æ•°æƒ³è±¡ä¸ºåº”ç”¨äºŽåŽŸå§‹æµ‹é‡æ•°æ®çš„ç‚¹ç§¯ã€‚æˆ‘ä»¬ä¼šä¸ºä¸¤ä¸ªè°ƒåº¦ä¼ é€’åŒä¸€é¢‘çŽ‡ï¼Œå°½ç®¡è¿™ä¸€é¢‘çŽ‡ä»…ç”±å‡½æ•°exc_scheduleä½¿ç”¨ã€‚

> \# Execution settings
>
> num_shots = 1024
>
> gnd_exc_program = assemble(\[gnd_schedule, exc_schedule\],
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'single\',
>
> shots=num_shots,
>
> schedule_los=\[{drive_chan: rough_qubit_frequency}\] \* 2)
>
> \# print(job.job_id())
>
> job = backend.run(gnd_exc_program)
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> gnd_exc_results = job.result(timeout=120)

è‡³æ­¤å°±èŽ·å¾—äº†ç»“æžœï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªç®€å•çš„æ•£ç‚¹å›¾ä¸Šå¯è§†åŒ–æ‰€å‡†å¤‡çš„ä¸¤ä¸ªæ€»ä½“ï¼Œè“è‰²æ˜¾ç¤ºåŸºæ€ç¨‹åºçš„ç»“æžœï¼Œçº¢è‰²æ˜¾ç¤ºæ¿€å‘æ€å‡†å¤‡ç¨‹åºçš„ç»“æžœã€‚

> gnd_results = gnd_exc_results.get_memory(0)\[:, qubit\]\*scale_factor
>
> exc_results = gnd_exc_results.get_memory(1)\[:, qubit\]\*scale_factor
>
> plt.figure(figsize=\[4,4\])
>
> \# Plot all the results
>
> \# All results from the gnd_schedule are plotted in blue
>
> plt.scatter(np.real(gnd_results), np.imag(gnd_results),
>
> s=5, cmap=\'viridis\', c=\'blue\', alpha=0.5, label=\'state_0\')
>
> \# All results from the exc_schedule are plotted in red
>
> plt.scatter(np.real(exc_results), np.imag(exc_results),
>
> s=5, cmap=\'viridis\', c=\'red\', alpha=0.5, label=\'state_1\')
>
> \# Plot a large dot for the average result of the 0 and 1 states.
>
> mean_gnd = np.mean(gnd_results) \# takes mean of both real and
> imaginary parts
>
> mean_exc = np.mean(exc_results)
>
> plt.scatter(np.real(mean_gnd), np.imag(mean_gnd),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0,
> label=\'state_0\_mean\')
>
> plt.scatter(np.real(mean_exc), np.imag(mean_exc),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0,
> label=\'state_1\_mean\')
>
> plt.ylabel(\'I \[a.u.\]\', fontsize=15)
>
> plt.xlabel(\'Q \[a.u.\]\', fontsize=15)
>
> plt.title(\"0-1 discrimination\", fontsize=15)
>
> plt.show()

![](pics/media/image340.png)

ä»Žä¸Šå›¾ä¸­å¯ä»¥æ¸…æ¥šåœ°çœ‹å‡ºç»“æžœåˆ†ä¸ºä¸¤ä¸ª$\left| 0 \right\rangle$å’Œ$|1\rangle$çš„ä¸¤ä¸ªç°‡ã€‚æ ¸æµ‹é‡ç»“æžœé€šè¿‡èƒ½å¤Ÿæœ€ä½³åŒºåˆ†è¿™ä¸¤ä¸ªç°‡çš„é‰´é¢‘å™¨åˆ†ç±»ï¼Œä½¿ç”¨meas_levelä½¿å¾—0å˜ä¸º1ã€‚æœ€ä½³åŒºåˆ†ä»…æ˜¯åœ¨IQå¹³é¢ä¸Šçš„ä¸€æ¡çº¿ï¼Œè¯¥çº¿ä¸Žä¸Šå›¾ä¸­çš„ä¸¤ä¸ªé»‘ç‚¹çš„å¹³å‡ç»“æžœç­‰è·ï¼Œå¹¶ä¸”åž‚ç›´äºŽè¿žæŽ¥ä¸¤é»‘ç‚¹çš„çº¿ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡è‹¥ä¸€ä¸ªç»™å®šçš„ç‚¹æŽ¥è¿‘äºŽåŸºæ€ç»“æžœçš„å‡å€¼è¿”å›ž0ï¼ŒæŽ¥è¿‘äºŽæ¿€å‘æ€ç»“æžœçš„å‡å€¼åˆ™è¿”å›ž1æ¥è®¾ç½®ä¸€ä¸ªå¿«é€Ÿçš„åˆ†ç±»å‡½æ•°ã€‚

> import math
>
> def classify(point: complex):
>
> \"\"\"Classify the given state as \|0\> or \|1\>.\"\"\"
>
> def distance(a, b):
>
> return math.sqrt((np.real(a) - np.real(b))\*\*2 + (np.imag(a) -
> np.imag(b))\*\*2)
>
> return int(distance(point, mean_exc) \< distance(point, mean_gnd))

#### 3.3 ä½¿ç”¨åè½¬æ¢å¤æµ‹é‡$\mathbf{T}_{\mathbf{1} }$

ä¸€ä¸ªé‡å­æ¯”ç‰¹çš„$T_{1}$æ—¶é—´æ˜¯å…¶ä»Žæ¿€å‘æ€å˜ä¸ºåŸºæ€çš„å»¶è¿Ÿæ—¶é—´ã€‚è¿™ä¸€æ—¶é—´éžå¸¸é‡è¦ï¼Œå› å…¶é™åˆ¶äº†æˆ‘ä»¬å¯åœ¨é‡å­è®¡ç®—æœºä¸Šè¿è¡Œç¨‹åºçš„å¯ç”¨æŒç»­æ—¶é—´ã€‚

å¯¹$T_{1}$æ—¶é—´çš„æµ‹é‡ä¸Žä¹‹å‰çš„å®žéªŒç›¸ä¼¼ï¼Œä½¿ç”¨å·²æ ¡å‡†çš„$\pi$è„‰å†²ã€‚æˆ‘ä»¬ä¼šå†æ¬¡ä½¿ç”¨å•ä¸ªé©±åŠ¨è„‰å†²ï¼ˆ$\pi$è„‰å†²ï¼‰ï¼Œç„¶åŽæ–½åŠ ä¸€ä¸ªæµ‹é‡è„‰å†²ã€‚ç„¶è€Œï¼Œæ­¤æ—¶å¹¶éžå¦‚åŒå…ˆå‰é‚£æ ·ç›´æŽ¥å¯¹å…¶æµ‹é‡ï¼Œæˆ‘ä»¬ä¼šå…ˆæ’å…¥ä¸€ä¸ªå»¶è¿Ÿå¹¶åœ¨ä¸åŒçš„å®žéªŒä¹‹é—´æ›´æ”¹å»¶è¿Ÿçš„æ—¶é—´ã€‚å½“ç”»å‡ºæµ‹å¾—ä¿¡å·ä¸Žå»¶è¿Ÿæ—¶é—´çš„å›¾å½¢æ—¶ï¼Œå°†ä¼šçœ‹åˆ°åœ¨é‡å­æ¯”ç‰¹é‡Šæ”¾èƒ½é‡æ—¶ä¿¡å·å‘ˆçŽ°æŒ‡æ•°å½¢å¼çš„è¡°å‡ã€‚è¿™ä¸€å»¶è¿Ÿæ—¶é—´å°±æ˜¯é‡å­æ¯”ç‰¹çš„é©°è±«æ—¶é—´$T_{1}$ã€‚

> \# T1 experiment parameters
>
> time_max_us = 450
>
> time_step_us = 6
>
> times_us = np.arange(1, time_max_us, time_step_us)
>
> \# Convert to units of dt
>
> delay_times_dt = times_us \* us / dt
>
> \# We will use the same \`pi_pulse\` and qubit frequency that we
> calibrated and used before
>
> \# Create schedules for the experiment
>
> t1_schedules = \[\]
>
> for delay in delay_times_dt:
>
> this_schedule = pulse.Schedule(name=f\"T1 delay = {delay \* dt/us}
> us\")
>
> this_schedule += Play(pi_pulse, drive_chan)
>
> this_schedule \|= measure \<\< int(delay)
>
> t1_schedules.append(this_schedule)

æˆ‘ä»¬ä¹Ÿå¯ä»¥æ£€æŸ¥$T_{1}$è°ƒåº¦ã€‚ä¸ºäº†èƒ½å¤ŸçœŸæ­£ç†è§£è¿™ä¸ªå®žéªŒçš„æ„ä¹‰ï¼Œå¯ä»¥æ›´æ”¹sched_idxçš„å€¼åŽè¿è¡Œä¸‹é¢çš„ä»£ç æ¥å°è¯•ä¸åŒçš„è°ƒåº¦ã€‚åœ¨å¢žå¤§sched_idxæ—¶ï¼Œæ‚¨å°†ä¼šçœ‹åˆ°æµ‹é‡è„‰å†²å¼€å§‹ã€‚

> sched_idx = 0
>
> t1_schedules\[sched_idx\].draw(label=True)

![](pics/media/image341.png)

> \# Execution settings
>
> num_shots = 256
>
> t1_experiment = assemble(t1_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots,
>
> schedule_los=\[{drive_chan: rough_qubit_frequency}\] \*
> len(t1_schedules))
>
> job = backend.run(t1_experiment)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> t1_results = job.result(timeout=120)
>
> t1_values = \[\]
>
> for i in range(len(times_us)):
>
> t1_values.append(t1_results.get_memory(i)\[qubit\]\*scale_factor)
>
> t1_values = np.real(t1_values)
>
> plt.scatter(times_us, t1_values, color=\'black\')
>
> plt.title(\"\$T_1\$ Experiment\", fontsize=15)
>
> plt.xlabel(\'Delay before measurement \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Signal \[a.u.\]\', fontsize=15)
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image342.png)

ç„¶åŽï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†æ•°æ®ä¸Žè¡°å‡æŒ‡æ•°è¿›è¡Œæ‹Ÿåˆï¼Œä»Žè€Œå¾—åˆ°$T_{1}$ï¼

> \# Fit the data
>
> fit_params, y_fit = fit_function(times_us, t1_values,
>
> lambda x, A, C, T1: (A \* np.exp(-x / T1) + C),
>
> \[-3, 3, 100\]
>
> )
>
> \_, \_, T1 = fit_params
>
> plt.scatter(times_us, t1_values, color=\'black\')
>
> plt.plot(times_us, y_fit, color=\'red\', label=f\"T1 = {T1:.2f} us\")
>
> plt.xlim(0, np.max(times_us))
>
> plt.title(\"\$T_1\$ Experiment\", fontsize=15)
>
> plt.xlabel(\'Delay before measurement \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Signal \[a.u.\]\', fontsize=15)
>
> plt.legend()
>
> plt.show()
>
> è¾“å‡ºï¼š

![](pics/media/image343.png)

### 4.ç¡®å®šé‡å­æ¯”ç‰¹çš„ç›¸å¹²æ€§ï¼ˆCoherenceï¼‰

#### 4.1 ä½¿ç”¨Ramseyå®žéªŒç²¾ç¡®æµ‹é‡é‡å­æ¯”ç‰¹çš„é¢‘çŽ‡

çŽ°åœ¨ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨æ›´ä½³çš„ç²¾åº¦ä¸Šç¡®å®šé‡å­æ¯”ç‰¹çš„é¢‘çŽ‡ï¼Œè¿™ä¸€è¿‡ç¨‹ä½¿ç”¨Ramseyè„‰å†²åºåˆ—æ¥å®Œæˆã€‚åœ¨è¿™ä¸ªè„‰å†²åºåˆ—ä¸­ï¼Œæˆ‘ä»¬ä¼šå…ˆæ–½åŠ ä¸€ä¸ª$\pi/2$çš„è„‰å†²å¹¶ç­‰å¾…$\Delta t$çš„æ—¶é—´ï¼Œä½œç”¨å¦ä¸€ä¸ª$\pi/2$è„‰å†²ã€‚ç”±äºŽæ‰€æµ‹é‡çš„ä¿¡å·æ¥è‡ªä¸Žè„‰å†²é¢‘çŽ‡ç›¸åŒçš„é‡å­æ¯”ç‰¹ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿè§‚å¯Ÿåˆ°æ‰€æ–½åŠ è„‰å†²å’Œé‡å­æ¯”ç‰¹ä¹‹é—´é¢‘çŽ‡å·®å¤„çš„æ³¢åŠ¨ã€‚

![](pics/media/image344.png)

> \# Ramsey experiment parameters
>
> time_max_us = 1.8
>
> time_step_us = 0.025
>
> times_us = np.arange(0.1, time_max_us, time_step_us)
>
> \# Convert to units of dt
>
> delay_times_dt = times_us \* us / dt
>
> \# Drive parameters
>
> \# The drive amplitude for pi/2 is simply half the amplitude of the pi
> pulse
>
> drive_amp = pi_amp / 2
>
> \# x_90 is a concise way to say pi_over_2; i.e., an X rotation of 90
> degrees
>
> x90_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> amp=drive_amp,
>
> sigma=drive_sigma,
>
> name=\'x90_pulse\')
>
> \# create schedules for Ramsey experiment
>
> ramsey_schedules = \[\]
>
> for delay in delay_times_dt:
>
> this_schedule = pulse.Schedule(name=f\"Ramsey delay = {delay \* dt /
> us} us\")
>
> this_schedule \|= Play(x90_pulse, drive_chan)
>
> this_schedule \|= Play(x90_pulse, drive_chan) \<\<
> int(this_schedule.duration + delay)
>
> this_schedule \|= measure \<\< int(this_schedule.duration)
>
> ramsey_schedules.append(this_schedule)

ä¸Ž$T_{1}$è°ƒåº¦ä¸€æ ·ï¼Œå¯å¤šæ¬¡æ‰§è¡Œä¸‹é¢çš„ä»£ç æ¥æ£€æŸ¥å·²ç»åˆ¶å®šçš„ä¸€äº›è°ƒåº¦ä¼šç»™å‡ºå¯ç¤ºã€‚å½“æ‚¨è§‚å¯Ÿramsey_scheduleæŒ‡æ•°å¢žé•¿æ—¶ï¼Œä¸¤ä¸ª$\pi/2$è„‰å†²ä¹‹é—´çš„å»¶è¿Ÿå°†ä¼šå¢žå¤§ã€‚

ramsey_schedules\[0\].draw(label=True)

![](pics/media/image345.png)

æ­¤å¤„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ªå¸¸ç”¨çš„å®žéªŒæŠ€å·§ã€‚æˆ‘ä»¬å°†ä½¿è„‰å†²ä¸Žä¸€ä¸ªå·²çŸ¥çš„é‡åå…±æŒ¯ï¼Œç§°ä¹‹ä¸ºå¤±è°å…†èµ«ï¼ˆdetuning_MHzï¼‰ã€‚æ‰€æµ‹å¾—Ramseyä¿¡å·æ‰€æ˜¾ç¤ºçš„é¢‘çŽ‡åº”æŽ¥è¿‘å¤±è°å…†èµ«ï¼Œä¸Žä¹‹æœ‰å°çš„åç§»ã€‚è¿™ä¸€å°åç§»å°±æ˜¯rough_qubit_frequencyä¸Žé‡å­æ¯”ç‰¹é¢‘çŽ‡ä¹‹é—´çš„ç¡®åˆ‡è·ç¦»ã€‚

> \# Execution settings
>
> num_shots = 256
>
> detuning_MHz = 2
>
> ramsey_frequency = round(rough_qubit_frequency + detuning_MHz \* MHz,
> 6) \# need ramsey freq in Hz
>
> ramsey_program = assemble(ramsey_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots,
>
> schedule_los=\[{drive_chan: ramsey_frequency}\]\*len(ramsey_schedules)
>
> )
>
> job = backend.run(ramsey_program)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> è¾“å‡ºï¼š
>
> Job Status: job has successfully run
>
> ramsey_results = job.result(timeout=120)
>
> ramsey_values = \[\]
>
> for i in range(len(times_us)):
>
> ramsey_values.append(ramsey_results.get_memory(i)\[qubit\]\*scale_factor)
>
> plt.scatter(times_us, np.real(ramsey_values), color=\'black\')
>
> plt.xlim(0, np.max(times_us))
>
> plt.title(\"Ramsey Experiment\", fontsize=15)
>
> plt.xlabel(\'Delay between X90 pulses \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.show()

![](pics/media/image346.png)

æˆ‘ä»¬å°†ä¼šæ‹Ÿåˆæ•°æ®è‡³ä¸Žä¸€ä¸ªæ­£å¼¦æ³¢å¹¶æå–æ‰€æ„Ÿå…´è¶£$\Delta f$çš„ä¿¡æ¯ã€‚

> fit_params, y_fit = fit_function(times_us, np.real(ramsey_values),
>
> lambda x, A, del_f\_MHz, C, B: (
>
> A \* np.cos(2\*np.pi\*del_f\_MHz\*x - C) + B
>
> ),
>
> \[5, 1./0.4, 0, 0.25\]
>
> )
>
> \# Off-resonance component
>
> \_, del_f\_MHz, \_, \_, = fit_params \# freq is MHz since times in us
>
> plt.scatter(times_us, np.real(ramsey_values), color=\'black\')
>
> plt.plot(times_us, y_fit, color=\'red\', label=f\"df =
> {del_f\_MHz:.2f} MHz\")
>
> plt.xlim(0, np.max(times_us))
>
> plt.xlabel(\'Delay between X90 pulses \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Ramsey Experiment\', fontsize=15)
>
> plt.legend()
>
> plt.show()

![](pics/media/image347.png)

è‡³æ­¤ï¼Œæˆ‘ä»¬çŸ¥é“del_f\_MhzåŽå°±å¯ä»¥æ›´æ–°å¯¹é‡å­æ¯”ç‰¹é¢‘çŽ‡çš„ä¼°è®¡äº†ã€‚

> precise_qubit_freq = rough_qubit_frequency + (del_f\_MHz -
> detuning_MHz) \* MHz \# get new freq in Hz
>
> print(f\"Our updated qubit frequency is now
> {round(precise_qubit_freq/GHz, 6)} GHz. \"
>
> f\"It used to be {round(rough_qubit_frequency / GHz, 6)} GHz\")
>
> è¾“å‡ºï¼š
>
> Our updated qubit frequency is now 4.974897 GHz. It used to be 4.97467
> GHz

#### ä½¿ç”¨å“ˆæ©å›žæ³¢ï¼ˆHahn Echoesï¼‰æµ‹é‡$\mathbf{T}_{\mathbf{2} }$

æŽ¥ç€ï¼Œæˆ‘ä»¬å°±å¯ä»¥æµ‹é‡é‡å­æ¯”ç‰¹çš„ç›¸å¹²æ—¶é—´$T_{2}$äº†ã€‚æœ¬æ¬¡å®žéªŒä¸­æ‰€ä½¿ç”¨çš„è„‰å†²åºåˆ—ç§°ä¹‹ä¸ºå“ˆæ©å›žæ³¢ï¼ˆHahn
Echoï¼‰ï¼Œè¿™ã€ä¸€æœ¯è¯­æ¥è‡ªæ ¸ç£å…±æŒ¯ï¼ˆNMRï¼‰å­¦ç•Œã€‚å“ˆæ©å›žæ³¢å®žéªŒä¸Žä¸Šæ–‡ä¸­æ‰€è®²è¯‰çš„Ramseyå®žéªŒéžå¸¸ç›¸è¯†ï¼Œéƒ½æ˜¯åœ¨ä¸¤ä¸ª$\pi/2$è„‰å†²ä¹‹é—´å¢žåŠ ä¸€ä¸ª$\pi$è„‰å†²ã€‚åœ¨æ—¶é—´$\tau$å¤„çš„$\pi$è„‰å†²ä½¿ç´¯ç§¯ç›¸ä½åå‘ï¼Œå¹¶åœ¨æ—¶é—´$2\tau$å¤„äº§ç”Ÿå›žæ³¢ï¼Œåœ¨æ­¤æ—¶æ–½åŠ æœ€åŽçš„$\pi/2$è„‰å†²è¿›è¡Œæµ‹é‡ã€‚

å“ˆæ©å›žæ³¢å®žéªŒçš„è¡°å‡æ—¶é—´ç»™å‡ºäº†ç›¸å¹²æ—¶é—´$T_{2}$ã€‚

> \# T2 experiment parameters
>
> tau_max_us = 200
>
> tau_step_us = 4
>
> taus_us = np.arange(2, tau_max_us, tau_step_us)
>
> \# Convert to units of dt
>
> delay_times_dt = taus_us \* us / dt
>
> \# We will use the pi_pulse and x90_pulse from previous experiments
>
> t2_schedules = \[\]
>
> for tau in delay_times_dt:
>
> this_schedule = pulse.Schedule(name=f\"T2 delay = {tau \*dt/us} us\")
>
> this_schedule \|= Play(x90_pulse, drive_chan)
>
> this_schedule \|= Play(pi_pulse, drive_chan) \<\<
> int(this_schedule.duration + tau)
>
> this_schedule \|= Play(x90_pulse, drive_chan) \<\<
> int(this_schedule.duration + tau)
>
> this_schedule \|= measure \<\< int(this_schedule.duration)
>
> t2_schedules.append(this_schedule)
>
> t2_schedules\[0\].draw(label=True)

![](pics/media/image348.png)

> \# Execution settings
>
> num_shots_per_point = 512
>
> t2_experiment = assemble(t2_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_point,
>
> schedule_los=\[{drive_chan: precise_qubit_freq}\]
>
> \* len(t2_schedules))
>
> job = backend.run(t2_experiment)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> t2_results = job.result(timeout=120)
>
> t2_values = \[\]
>
> for i in range(len(taus_us)):
>
> t2_values.append(t2_results.get_memory(i)\[qubit\]\*scale_factor)
>
> plt.scatter(2\*taus_us, np.real(t2_values), color=\'black\')
>
> plt.xlabel(\'Delay between X90 pulse and \$\\pi\$ pulse
> \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Hahn Echo Experiment\', fontsize=15)
>
> plt.show()

![](pics/media/image349.png)

> fit_params, y_fit = fit_function(2\*taus_us, np.real(t2_values),
>
> lambda x, A, B, T2: (A \* np.exp(-x / T2) + B),
>
> \[-3, 0, 100\])
>
> \_, \_, T2 = fit_params
>
> print()
>
> plt.scatter(2\*taus_us, np.real(t2_values), color=\'black\')
>
> plt.plot(2\*taus_us, y_fit, color=\'red\', label=f\"T2 = {T2:.2f}
> us\")
>
> plt.xlim(0, np.max(2\*taus_us))
>
> plt.xlabel(\'Delay between X90 pulse and \$\\pi\$ pulse
> \[\$\\mu\$s\]\', fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Hahn Echo Experiment\', fontsize=15)
>
> plt.legend()
>
> plt.show()

![](pics/media/image350.png)

##### çº§è”åŠ¨æ€è§£è€¦ï¼ˆConcatenated Dynamical Decouplingï¼‰

å•ä¸ª$\pi$è„‰å†²èƒ½å¤Ÿæ¶ˆé™¤ç”±äºŽåè½¬ç›¸ä½ç´¯ç§¯è€Œäº§ç”Ÿçš„å‡†é™æ€å™ªå£°ã€‚é€šè¿‡è¿žç»­æ–½åŠ å‡ ä¸ª$\pi$è„‰å†²ï¼Œå¯ä»¥å°†æ­¤æ¦‚å¿µæ‰©å±•åˆ°æ— æ³•è¿‘ä¼¼ä¸ºå‡†é™æ€çš„å™ªå£°ã€‚è¿™ä¸€æŠ€æœ¯é€šå¸¸ç§°ä¸ºåŠ¨æ€åŽ»è€¦ï¼ˆdynamical
decouplingï¼‰ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥æ¶ˆé™¤ä¸åŒé¢‘çŽ‡çš„å™ªå£°ï¼Œå¹¶å¯ä»Žé‡å­æ¯”ç‰¹ä¸­æå–æ›´é•¿çš„ç›¸å¹²æ—¶é—´ã€‚

> \# DD experiment parameters
>
> tau_us_min = 1
>
> tau_us_max = 40
>
> tau_step_us = 1.5
>
> taus_us = np.arange(tau_us_min, tau_us_max, tau_step_us)
>
> \# Convert to units of dt
>
> taus_dt = taus_us \* us / dt
>
> num_pi_pulses = 6 \# apply 6 pi pulses
>
> print(f\"Total time ranges from {2.\*num_pi_pulses\*taus_us\[0\]} to
> {2.\*num_pi_pulses\*taus_us\[-1\]} us\")
>
> è¾“å‡ºï¼š
>
> Total time ranges from 12.0 to 462.0 us
>
> T2DD_schedules = \[\]
>
> for delay in taus_dt:
>
> this_schedule = pulse.Schedule(name=f\"T2DD delay = {delay \* dt/us}
> us\")
>
> this_schedule \|= Play(x90_pulse, drive_chan)
>
> this_schedule \|= Play(pi_pulse, drive_chan) \<\<
> int(this_schedule.duration + delay)
>
> for \_ in range(num_pi_pulses - 1):
>
> this_schedule \|= Play(pi_pulse, drive_chan) \<\<
> int(this_schedule.duration + 2\*delay)
>
> this_schedule \|= Play(x90_pulse, drive_chan) \<\<
> int(this_schedule.duration + delay)
>
> this_schedule \|= measure \<\< int(this_schedule.duration)
>
> T2DD_schedules.append(this_schedule)
>
> T2DD_schedules\[0\].draw(label=True)

![](pics/media/image351.png)

> num_shots_per_point = 1024
>
> T2DD_experiment = assemble(T2DD_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=num_shots_per_point,
>
> schedule_los=\[{drive_chan: precise_qubit_freq}\]
>
> \* len(T2DD_schedules))
>
> job = backend.run(T2DD_experiment)
>
> \# print(job.job_id())
>
> job_monitor(job)
>
> T2DD_results = job.result(timeout=120)
>
> times_us = 2.\*num_pi_pulses\*taus_us
>
> DD_values = \[\]
>
> for i in range(len(taus_us)):
>
> DD_values.append(T2DD_results.get_memory(i)\[qubit\]\*scale_factor)
>
> plt.scatter(times_us, np.real(DD_values), color=\'black\')
>
> plt.xlim(0, np.max(times_us))
>
> plt.xlabel(\'Total time before measurement \[\$\\mu\$s\]\',
> fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Dynamical Decoupling Experiment\', fontsize=15)
>
> plt.show()

![](pics/media/image352.png)

> \# Fit the data
>
> fit_func = lambda x, A, B, T2DD: (A \* np.exp(-x / T2DD) + B)
>
> fitparams, conv = curve_fit(fit_func, times_us, np.real(DD_values),
> \[3.5, 0.8, 150\])
>
> \_, \_, T2DD = fitparams
>
> plt.scatter(times_us, np.real(DD_values), color=\'black\')
>
> plt.plot(times_us, fit_func(times_us, \*fitparams), color=\'red\',
> label=f\"T2DD = {T2DD:.2f} us\")
>
> plt.xlim(\[0, np.max(times_us)\])
>
> plt.xlabel(\'Total time before measurement \[\$\\mu\$s\]\',
> fontsize=15)
>
> plt.ylabel(\'Measured Signal \[a.u.\]\', fontsize=15)
>
> plt.title(\'Dynamical Decoupling Experiment\', fontsize=15)
>
> plt.legend()
>
> plt.show()

![](pics/media/image353.png)

### 5. å‚è€ƒæ–‡çŒ®

1.  H. Abraham, I. Y. Akhalwaya, G. Aleksandrowicz, T. Alexander, G.
    Alexandrowics, E. Arbel, A. Asfaw, C. Azaustre, P. Barkoutsos, G.
    Barron, L. Bello, Y. Ben-Haim, L. S. Bishop, S. Bosch, D. Bucher,
    CZ, F. Cabrera, P. Calpin, L. Capelluto, J. Carballo, C.-F. Chen, A.
    Chen, R. Chen, J. M. Chow, C. Claus, A. W. Cross, A. J. Cross, J.
    Cruz- Benito, C. Culver, A. D. C Ìorcoles-Gonzales, S. Dague, M.
    Dartiailh, A. R. Davila, D. Ding, E. Dumitrescu, K. Dumon, I.
    Duran, P. Eendebak, D. Egger, M. Everitt, P. M. Fern Ìandez, A.
    Frisch, A. Fuhrer, J. Gacon, Gadi, B. G. Gago, J. M. Gambetta, L.
    Garcia, S. Garion, Gawel-Kus, L. Gil, J. Gomez-Mosquera, S. de la
    Puente Gonz Ìalez, D. Green-
    berg,J.A.Gunnels,I.Haide,I.Hamamura,V.Havlicek,J.Hellmers,Lô°€.Herok,H.Horii, C.
    Howington, W. Hu, S. Hu, H. Imai, T. Imamichi, R. Iten, T. Itoko, A.
    Javadi-Abhari, Jessica, K. Johns, N. Kanazawa, A. Karazeev, P.
    Kassebaum, V. Krishnan, K. Kr- sulich, G. Kus, R. LaRose, R.
    Lambert, J. Latone, S. Lawrence, P. Liu, P. B. Z. Mac, Y. Maeng, A.
    Malyshev, J. Marecek, M. Marques, D. Mathews, A. Matsuo, D. T. Mc-
    Clure, C. McGarry, D. McKay, S. Meesala, A. Mezzacapo, R. Midha, Z.
    Minev, P. Mu- rali, J. Mu Ìˆggenburg, D. Nadlinger, G. Nannicini, P.
    Nation, Y. Naveh, Nick-Singstock, P. Niroula, H. Norlen, L. J.
    O'Riordan, S. Oud, D. Padilha, H. Paik, S. Perriello, A. Phan, M.
    Pistoia, A. Pozas-iKerstjens, V. Prutyanov, J. P Ìerez, Quintiii, R.
    Raymond, R. M.-C. Redondo, M. Reuter, D. M. Rodr ÌÄ±guez, M. Ryu, M.
    Sandberg, N. Sathaye, B. Schmitt, C. Schnabel, T. L. Scholten, E.
    Schoute, I. F. Sertage, Y. Shi, A. Silva, Y. Siraichi, S.
    Sivarajah, J. A. Smolin, M. Soeken, D. Steenken, M. Stypulkoski, H.
    Takahashi, C. Taylor, P. Taylour, S. Thomas, M. Tillet, M. Tod, E.
    de la Torre, K. Trabing, M. Treinish, TrishaPe, W. Turner, Y.
    Vaknin, C. R. Valcarce, F. Varchon, D. Vogt- Lee, C. Vuillot, J.
    Weaver, R. Wieczorek, J. A. Wildstrom, R. Wille, E. Winston, J. J.
    Woehr, S. Woerner, R. Woo, C. J. Wood, R. Wood, S. Wood, J.
    Wootton, D. Yeralin, J. Yu, L. Zdanski, Zoufalc, azulehner,
    drholmie, fanizzamarco, kanejess, klinvill, merav aharoni, ordmoj,
    tigerjack, yang.luh, and yotamvakninibm, "Qiskit: An open-source
    framework for quantum computing," 2019.

2.  D. C. McKay, T. Alexander, L. Bello, M. J. Biercuk, L. Bishop, J.
    Chen, J. M. Chow, A. D. C Ìorcoles, D. Egger, S. Filipp, J.
    Gomez, M. Hush, A. Javadi-Abhari, D. Moreda, P. Nation, B.
    Paulovicks, E. Winston, C. J. Wood, J. Wootton, and J. M. Gambetta,
    "Qiskit backend specifications for OpenQASM and OpenPulse
    experiments," 2018.

æ³¨ï¼š"Qiskit Pulse"ä»¥å‰ç§°ä¸º"OpenPulse"ã€‚

6.2 è®¿é—®æ›´é«˜çš„èƒ½æ€
------------------

åœ¨å¤§éƒ¨åˆ†çš„é‡å­ç®—æ³•/åº”ç”¨ä¸­ï¼Œè®¡ç®—æ˜¯åœ¨ç”±$|0\rangle$å’Œ$|1\rangle$å¼ æˆçš„äºŒç»´ç©ºé—´ä¸Šè¿›è¡Œã€‚ç„¶è€Œï¼Œåœ¨IBMç¡¬ä»¶ä¸­è¿˜å­˜åœ¨ä¸å¸¸ç”¨åˆ°çš„æ›´é«˜èƒ½æ€ã€‚æœ¬èŠ‚çš„é‡ç‚¹æ˜¯ä½¿ç”¨Qiskit
PulseæŽ¢ç´¢è¿™äº›çŠ¶æ€ã€‚å…¶ä¸­æ¼”ç¤ºäº†å¦‚ä½•æ¿€å‘æ€$|2\rangle$ï¼Œå¹¶æž„å»ºé‰´åˆ«å™¨æ¥å¯¹æ€$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$è¿›è¡Œè¯†åˆ«ã€‚

å»ºè®®æ‚¨å…ˆé˜…è¯»ä¸Šä¸€ç« ï¼Œç„¶åŽå†é˜…è¯»æœ¬èŠ‚ã€‚è¿˜å»ºè®®æ‚¨é˜…è¯»Qiskit Pulseè¯´æ˜Ž\[1\]ã€‚

### ç‰©ç†èƒŒæ™¯

çŽ°åœ¨ï¼Œæˆ‘ä»¬æä¾›æœ‰å…³transmoné‡å­æ¯”ç‰¹ï¼ˆtransmission line shunted plasma
oscillation
qubitï¼‰ç‰©ç†å­¦çš„èƒŒæ™¯çŸ¥è¯†ï¼Œå…¶ä¸ºå¤§é‡IBMé‡å­ç¡¬ä»¶çš„åŸºç¡€ã€‚è¿™äº›ç³»ç»ŸåŒ…å«ç”±çº¦ç‘Ÿå¤«æ£®ç»“ï¼ˆJosephson
Junctionï¼ŒJJï¼‰å’Œç”µå®¹å™¨ç»„æˆçš„è¶…å¯¼ç”µè·¯ã€‚å¯¹äºŽé‚£äº›ä¸ç†Ÿæ‚‰è¶…å¯¼ç”µè·¯çš„äººï¼Œè¯·å‚è§\[2\]çš„è¯„è®ºã€‚è¯¥ç³»ç»Ÿçš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$$H = 4E_{C}n^{2} - E_{J}\cos(\phi)$$

å…¶ä¸­$E_{C}$å’Œ$E_{J}$è¡¨ç¤ºç”µå®¹å™¨å’Œçº¦ç‘Ÿå¤«æ£®èƒ½é‡ï¼Œ$n$æ˜¯ç®—å­çš„ç¼©å‡ç”µè·æ•°ï¼Œ$\phi$æ˜¯é€šè¿‡çº¦ç‘Ÿå¤«æ£®ç»“æ‰€å‡å°‘çš„é€šé‡ã€‚æˆ‘ä»¬ä»¥$\hslash = 1$ä¸ºå•ä½ã€‚

Transmoné‡å­æ¯”ç‰¹åœ¨å°$\phi$çš„çŠ¶æ€ä¸‹å®šä¹‰ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨æ³°å‹’çº§æ•°ä¸­æ‰©å±•$E_{J}\cos(\phi)$ï¼ˆå¿½ç•¥å¸¸æ•°é¡¹ï¼‰

$$E_{J}\cos(\phi) \approx \frac{1}{2}E_{J}\phi^{2} - \frac{1}{24}E_{J}\phi^{4}\mathcal{+ O(}\phi^{6})$$

äºŒæ¬¡é¡¹$\phi^{2}$å®šä¹‰äº†æ ‡å‡†è°æ³¢æŒ¯è¡å™¨ã€‚æ¯å¢žåŠ ä¸€é¡¹å°±ä¼šå¯¼è‡´å¤±è°ã€‚

ä½¿ç”¨å…³ç³»å¼$n \sim (a - a^{\dagger}),\phi \sim (a + a^{\dagger})$ï¼ˆfor
raising, lowering operators
$a^{\dagger},a$ï¼‰ï¼Œå¯ä»¥è¯æ˜Žè¯¥ç³»ç»Ÿç±»ä¼¼äºŽå…·æœ‰å“ˆå¯†é¡¿é‡çš„DuffingæŒ¯è¡å™¨ã€‚

$$H = \omega a^{\dagger}a + \frac{\alpha}{2}a^{\dagger}a^{\dagger}\text{aa}$$

å…¶ä¸­$\omega$ç»™å‡ºäº†$0 \rightarrow 1$æ¿€åŠ±é¢‘çŽ‡ï¼ˆ$\omega \equiv \omega 0 \rightarrow 1$ï¼‰ï¼Œ$\alpha$æ˜¯$0 \rightarrow 1$å’Œ$1 \rightarrow 2$é¢‘çŽ‡ï¼ˆ$\alpha \equiv \omega 1 \rightarrow 2 - - \omega 0 \rightarrow 1$ï¼‰ä¹‹é—´çš„éžè°æ€§ã€‚å¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ é©±åŠ¨é¡¹ã€‚

å¦‚æžœé€‰æ‹©æŒ‡å®šçš„æ ‡å‡†äºŒç»´å­ç©ºé—´ï¼Œåˆ™å¯ä½¿$|\alpha|$è¶³å¤Ÿå¤§æˆ–ä½¿ç”¨ç‰¹æ®Šçš„æŽ§åˆ¶æŠ€æœ¯æ¥æŠ‘åˆ¶æ›´é«˜çš„èƒ½æ€ã€‚

### å†…å®¹

1.  å¼€å§‹

2.  åŒºåˆ†æ€0å’Œæ€1

    1.  æ€0-\>æ€1 é¢‘çŽ‡æ‰«æ

    2.  æ€0-\>æ€1 Rabiå®žéªŒ

    3.  æž„å»ºåŒºåˆ†0ã€1çš„é‰´é¢‘å™¨

3.  åŒºåˆ†æ€0ã€æ€1å’Œæ€2

> 2.1 è®¡ç®—ä½¿å¾—$1 \rightarrow 2$çš„é¢‘çŽ‡
>
> 2.1.1 ä½¿ç”¨è¾¹å¸¦æ³•å¯¹$1 \rightarrow 2$è¿‡ç¨‹è¿›è¡Œé¢‘çŽ‡æ‰«æ
>
> 2.2 æ€1-\>æ€2 Rabiå®žéªŒ
>
> 2.3 æž„å»ºåŒºåˆ†0ã€1åŠ2çš„é‰´é¢‘å™¨

3\. å‚è€ƒæ–‡çŒ®

### å¼€å§‹

æˆ‘ä»¬ç”±å¯¼å…¥ç›¸å…³çš„åº“ä»¥åŠå®šä¹‰ä¸€ä¸‹é»˜è®¤å˜é‡å€¼å¼€å§‹ã€‚æ­¤å¤„é€‰æ‹©é‡å­æ¯”ç‰¹0å¹¶åœ¨å…¬ç”¨å•é‡å­æ¯”ç‰¹è®¾å¤‡ibmq_armonkä¸Šè¿›è¡Œå®žéªŒã€‚

> import numpy as np
>
> import matplotlib.pyplot as plt
>
> from scipy.optimize import curve_fit
>
> from scipy.signal import find_peaks
>
> from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
>
> from sklearn.model_selection import train_test_split
>
> import qiskit.pulse as pulse
>
> import qiskit.pulse.pulse_lib as pulse_lib
>
> from qiskit.compiler import assemble
>
> from qiskit.pulse.commands import SamplePulse
>
> from qiskit.tools.monitor import job_monitor
>
> import warnings
>
> warnings.filterwarnings(\'ignore\')
>
> from qiskit.tools.jupyter import \*
>
> %matplotlib inline
>
> from qiskit import IBMQ
>
> IBMQ.load_account()
>
> provider = IBMQ.get_provider(hub=\'ibm-q\', group=\'open\',
> project=\'main\')
>
> backend = provider.get_backend(\'ibmq_armonk\')
>
> backend_config = backend.configuration()
>
> assert backend_config.open_pulse, \"Backend doesn\'t support Pulse\"
>
> dt = backend_config.dt
>
> backend_defaults = backend.defaults()
>
> \# unit conversion factors -\> all backend properties returned in SI
> (Hz, sec, etc)
>
> GHz = 1.0e9 \# Gigahertz
>
> MHz = 1.0e6 \# Megahertz
>
> us = 1.0e-6 \# Microseconds
>
> ns = 1.0e-9 \# Nanoseconds
>
> qubit = 0 \# qubit we will analyze
>
> default_qubit_freq = backend_defaults.qubit_freq_est\[qubit\] \#
> Default qubit frequency in Hz.
>
> print(f\"Qubit {qubit} has an estimated frequency of
> {default_qubit_freq/ GHz} GHz.\")
>
> \# scale data (specific to each device)
>
> scale_factor = 1e-14
>
> \# number of shots for our experiments
>
> NUM_SHOTS = 1024
>
> \#\#\# Collect the necessary channels
>
> drive_chan = pulse.DriveChannel(qubit)
>
> meas_chan = pulse.MeasureChannel(qubit)
>
> acq_chan = pulse.AcquireChannel(qubit)
>
> è¾“å‡ºï¼š
>
> Qubit 0 has an estimated frequency of 4.974291768298264 GHz.

ä¸‹é¢çš„ä»£ç å®šäº†ä¸€äº›è¾…åŠ©å‡½æ•°ï¼š

> def get_job_data(job, average):
>
> \"\"\"Retrieve data from a job that has already run.
>
> Args:
>
> job (Job): The job whose data you want.
>
> average (bool): If True, gets the data assuming data is an average.
>
> If False, gets the data assuming it is for single shots.
>
> Return:
>
> list: List containing job result data.
>
> \"\"\"
>
> job_results = job.result(timeout=120) \# timeout parameter set to 120
> s
>
> result_data = \[\]
>
> for i in range(len(job_results.results)):
>
> if average: \# get avg data
>
> result_data.append(job_results.get_memory(i)\[qubit\]\*scale_factor)
>
> else: \# get single data
>
> result_data.append(job_results.get_memory(i)\[:,
> qubit\]\*scale_factor)
>
> return result_data
>
> def get_closest_multiple_of_16(num):
>
> \"\"\"Compute the nearest multiple of 16. Needed because pulse enabled
> devices require
>
> durations which are multiples of 16 samples.
>
> \"\"\"
>
> return (int(num) - (int(num)%16))

è®¾ç½®ä¸€äº›é©±åŠ¨è„‰å†²å’Œæµ‹é‡çš„é»˜è®¤å‚æ•°ã€‚ä½¿ç”¨æŒ‡ä»¤è°ƒåº¦æ˜ å°„ï¼ˆåŽç«¯é»˜è®¤å€¼ï¼‰ä¸­çš„measureå‘½ä»¤ï¼Œä»¥ä¾¿ä½¿ç”¨æ–°æ ¡å‡†å¯¹å…¶è¿›è¡Œæ›´æ–°ã€‚

> \# Drive pulse parameters (us = microseconds)
>
> drive_sigma_us = 0.075 \# This determines the actual width of the
> gaussian
>
> drive_samples_us = drive_sigma_us\*8 \# This is a truncating
> parameter, because gaussians don\'t have
>
> \# a natural finite length
>
> drive_sigma = get_closest_multiple_of_16(drive_sigma_us \* us /dt) \#
> The width of the gaussian in units of dt
>
> drive_samples = get_closest_multiple_of_16(drive_samples_us \* us /dt)
> \# The truncating parameter in units of dt
>
> \# Find out which measurement map index is needed for this qubit
>
> meas_map_idx = None
>
> for i, measure_group in enumerate(backend_config.meas_map):
>
> if qubit in measure_group:
>
> meas_map_idx = i
>
> break
>
> assert meas_map_idx is not None, f\"Couldn\'t find qubit {qubit} in
> the meas_map!\"
>
> \# Get default measurement pulse from instruction schedule map
>
> inst_sched_map = backend_defaults.instruction_schedule_map
>
> measure = inst_sched_map.get(\'measure\',
> qubits=backend_config.meas_map\[meas_map_idx\])

### åŒºåˆ†æ€$\mathbf{|0}\mathbf{\rangle}$å’Œæ€$\mathbf{|1}\mathbf{\rangle}$

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæž„å»ºä¸€ä¸ªåŒºåˆ†æ ‡å‡†æ€$|0\rangle$å’Œ$|1\rangle$çš„é‰´é¢‘å™¨ã€‚è¯¥é‰´é¢‘å™¨çš„ä»»åŠ¡æ˜¯æŽ¥å—meas_level=1æ—¶çš„å¤æ•°æ•°æ®å¹¶å°†å…¶åˆ†ç±»ä¸ºmeas_level=2çš„æ ‡å‡†æ€$|0\rangle$å’Œ$|1\rangle$ï¼Œæ­¤å¤„ä¼šåˆ©ç”¨åˆ°ä¸Šä¸€ç« ä¸­çš„å†…å®¹ã€‚æ‰€äº§ç”Ÿçš„ç»“æžœåœ¨æ¿€å‘æ›´é«˜çš„èƒ½æ€æ—¶å¿…ä¼šè¢«ä½¿ç”¨åˆ°ï¼Œè€Œæ›´é«˜çš„èƒ½æ€æ˜¯æœ¬notebookçš„é‡ç‚¹ã€‚

#### 1.1 æ€0-\>æ€1 é¢‘çŽ‡æ‰«æ

æ­£å¦‚ä¸Šä¸€ç« ä¸­æ‰€è¿°ï¼Œæ ¡å‡†é‡å­æ¯”ç‰¹é¢‘çŽ‡çš„ç¬¬ä¸€æ­¥æ˜¯æž„å»ºé‰´é¢‘å™¨ã€‚

> def create_ground_freq_sweep_program(freqs, drive_power):
>
> \"\"\"Builds a program that does a freq sweep by exciting the ground
> state.
>
> Depending on drive power this can reveal the 0-\>1 frequency or the
> 0-\>2 frequency.
>
> Args:
>
> freqs (np.ndarray(dtype=float)): Numpy array of frequencies to sweep.
>
> drive_power (float) : Value of drive amplitude.
>
> Raises:
>
> ValueError: Raised if use more than 75 frequencies; currently, an
> error will be thrown on the backend
>
> if you try to do this.
>
> Returns:
>
> Qobj: Program for ground freq sweep experiment.
>
> \"\"\"
>
> if len(freqs) \> 75:
>
> raise ValueError(\"You can only run 75 schedules at a time.\")
>
> \# print information on the sweep
>
> print(f\"The frequency sweep will go from {freqs\[0\] / GHz} GHz to
> {freqs\[-1\]/ GHz} GHz using {len(freqs)} frequencies. The drive power
> is {drive_power}.\")
>
> \# Define the drive pulse
>
> ground_sweep_drive_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_power,
>
> name=\'ground_sweep_drive_pulse\')
>
> \# Create the base schedule
>
> schedule = pulse.Schedule(name=\'Frequency sweep starting from ground
> state.\')
>
> schedule \|= ground_sweep_drive_pulse(drive_chan)
>
> schedule \|= measure \<\< schedule.duration
>
> \# define frequencies for the sweep
>
> schedule_freqs = \[{drive_chan: freq} for freq in freqs\]
>
> \# assemble the program
>
> \# Note: we only require a single schedule since each does the same
> thing;
>
> \# for each schedule, the LO frequency that mixes down the drive
> changes
>
> \# this enables our frequency sweep
>
> ground_freq_sweep_program = assemble(schedule,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=schedule_freqs)
>
> return ground_freq_sweep_program
>
> \# We will sweep 40 MHz around the estimated frequency, with 75
> frequencies
>
> num_freqs = 75
>
> ground_sweep_freqs = default_qubit_freq + np.linspace(-20\*MHz,
> 20\*MHz, num_freqs)
>
> ground_freq_sweep_program =
> create_ground_freq_sweep_program(ground_sweep_freqs, drive_power=0.3)
>
> è¾“å‡ºï¼š
>
> The frequency sweep will go from 4.954291768298265 GHz to
> 4.994291768298265
>
> ground_freq_sweep_job = backend.run(ground_freq_sweep_program)
>
> print(ground_freq_sweep_job.job_id())
>
> job_monitor(ground_freq_sweep_job)
>
> è¾“å‡ºï¼š
>
> 5e8d9cfaff553c0012179aa4
>
> Job Status: job has successfully run
>
> \# Get the job data (average)
>
> ground_freq_sweep_data = get_job_data(ground_freq_sweep_job,
> average=True)

å°†æ•°æ®æ•°æ®æ‹Ÿåˆè‡³ä¸€æ¡æ´›ä¼¦å…¹æ›²çº¿å¹¶æå–æ ¡å‡†é¢‘çŽ‡ã€‚

> def fit_function(x_values, y_values, function, init_params):
>
> \"\"\"Fit a function using scipy curve_fit.\"\"\"
>
> fitparams, conv = curve_fit(function, x_values, y_values, init_params)
>
> y_fit = function(x_values, \*fitparams)
>
> return fitparams, y_fit
>
> \# do fit in Hz
>
> (ground_sweep_fit_params,
>
> ground_sweep_y\_fit) = fit_function(ground_sweep_freqs,
>
> ground_freq_sweep_data,
>
> lambda x, A, q_freq, B, C: (A / np.pi) \* (B / ((x - q_freq)\*\*2 +
> B\*\*2)) + C,
>
> \[7, 4.975\*GHz, 1\*GHz, 3\*GHz\] \# initial parameters for curve_fit
>
> )
>
> \# Note: we are only plotting the real part of the signal
>
> plt.scatter(ground_sweep_freqs/GHz, ground_freq_sweep_data,
> color=\'black\')
>
> plt.plot(ground_sweep_freqs/GHz, ground_sweep_y\_fit, color=\'red\')
>
> plt.xlim(\[min(ground_sweep_freqs/GHz), max(ground_sweep_freqs/GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\", fontsize=15)
>
> plt.ylabel(\"Measured Signal \[a.u.\]\", fontsize=15)
>
> plt.title(\"0-\>1 Frequency Sweep\", fontsize=15)
>
> plt.show()

![](pics/media/image354.png)

> \_, cal_qubit_freq, \_, \_ = ground_sweep_fit_params
>
> print(f\"We\'ve updated our qubit frequency estimate from \"
>
> f\"{round(default_qubit_freq/GHz, 7)} GHz to
> {round(cal_qubit_freq/GHz, 7)} GHz.\")
>
> è¾“å‡ºï¼š
>
> We\'ve updated our qubit frequency estimate from 4.9742918 GHz to
> 4.9743098 GHz.

#### 1.2 æ€0-\>æ€1 Rabiå®žéªŒ

ç„¶åŽï¼Œè¿è¡ŒRabiå®žéªŒè®¡ç®—$0 \rightarrow 1$æ—¶çš„$\pi$è„‰å†²çš„å¹…å€¼ã€‚ä¸€ä¸ª$\pi$è„‰å†²æ˜¯å°†æ€$|0\rangle$è½¬æ¢ä¸ºæ€$|1\rangle$çš„è„‰å†²ï¼ˆåœ¨å¸ƒæ´›èµ«çƒä¸­çš„ä¸€ä¸ª$\pi$æ—‹è½¬ï¼‰ã€‚

> \# experimental configuration
>
> num_rabi_points = 50 \# number of experiments (ie amplitudes to sweep
> out)
>
> \# Drive amplitude values to iterate over: 50 amplitudes evenly spaced
> from 0 to 0.75
>
> drive_amp_min = 0
>
> drive_amp_max = 0.75
>
> drive_amps = np.linspace(drive_amp_min, drive_amp_max,
> num_rabi_points)
>
> \# Create schedule
>
> rabi_01_schedules = \[\]
>
> \# loop over all drive amplitudes
>
> for ii, drive_amp in enumerate(drive_amps):
>
> \# drive pulse
>
> rabi_01_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> amp=drive_amp,
>
> sigma=drive_sigma,
>
> name=\'rabi_01_pulse\_%d\' % ii)
>
> \# add commands to schedule
>
> schedule = pulse.Schedule(name=\'Rabi Experiment at drive amp = %s\' %
> drive_amp)
>
> schedule \|= rabi_01_pulse(drive_chan)
>
> schedule \|= measure \<\< schedule.duration \# shift measurement to
> after drive pulse
>
> rabi_01_schedules.append(schedule)
>
> \# Assemble the schedules into a program
>
> \# Note: We drive at the calibrated frequency.
>
> rabi_01_expt_program = assemble(rabi_01_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\]
>
> \* num_rabi_points)
>
> rabi_01_job = backend.run(rabi_01_expt_program)
>
> print(rabi_01_job.job_id())
>
> job_monitor(rabi_01_job)
>
> è¾“å‡ºï¼š
>
> 5e8d9d8c76f61000120ff6ca
>
> Job Status: job has successfully run
>
> \# Get the job data (average)
>
> rabi_01_data = get_job_data(rabi_01_job, average=True)
>
> def baseline_remove(values):
>
> \"\"\"Center data around 0.\"\"\"
>
> return np.array(values) - np.mean(values)
>
> \# Note: Only real part of data is plotted
>
> rabi_01_data = np.real(baseline_remove(rabi_01_data))
>
> (rabi_01_fit_params,
>
> rabi_01_y\_fit) = fit_function(drive_amps,
>
> rabi_01_data,
>
> lambda x, A, B, drive_01_period, phi:
> (A\*np.cos(2\*np.pi\*x/drive_01_period - phi) + B),
>
> \[4, -4, 0.5, 0\])
>
> plt.scatter(drive_amps, rabi_01_data, color=\'black\')
>
> plt.plot(drive_amps, rabi_01_y\_fit, color=\'red\')
>
> drive_01_period = rabi_01_fit_params\[2\]
>
> \# account for phi in computing pi amp
>
> pi_amp_01 = (drive_01_period/2/np.pi)
> \*(np.pi+rabi_01_fit_params\[3\])
>
> plt.axvline(pi_amp_01, color=\'red\', linestyle=\'\--\')
>
> plt.axvline(pi_amp_01+drive_01_period/2, color=\'red\',
> linestyle=\'\--\')
>
> plt.annotate(\"\", xy=(pi_amp_01+drive_01_period/2, 0),
> xytext=(pi_amp_01,0), arrowprops=dict(arrowstyle=\"\<-\>\",
> color=\'red\'))
>
> plt.annotate(\"\$\\pi\$\", xy=(pi_amp_01-0.03, 0.1), color=\'red\')
>
> plt.xlabel(\"Drive amp \[a.u.\]\", fontsize=15)
>
> plt.ylabel(\"Measured signal \[a.u.\]\", fontsize=15)
>
> plt.title(\'0-\>1 Rabi Experiment\', fontsize=15)
>
> plt.show()

![](pics/media/image4.png)

> print(f\"Pi Amplitude (0-\>1) = {pi_amp_01}\")
>
> è¾“å‡ºï¼š
>
> Pi Amplitude (0-\>1) = 0.24347362693346655

ä½¿ç”¨ä¸Šè¿°ç»“æžœå°±å¯ä»¥å®šä¹‰$0 \rightarrow 1$çš„$\pi$è„‰å†²äº†ã€‚

> pi_pulse_01 = pulse_lib.gaussian(duration=drive_samples,
>
> amp=pi_amp_01,
>
> sigma=drive_sigma,
>
> name=\'pi_pulse_01\')

#### 1.3 æž„å»ºåŒºåˆ†0ã€1çš„é‰´é¢‘å™¨

ç»è¿‡ä¸Šè¿°çš„å‡†å¤‡å·¥ä½œï¼Œæˆ‘ä»¬å·²ç»èŽ·å¾—äº†æ ¡å‡†çš„é¢‘çŽ‡ä»¥åŠ$\pi$è„‰å†²ï¼ŒæŽ¥ç€å°±æ˜¯æž„å»ºåŒºåˆ†æ€$|0\rangle$å’Œæ€$|1\rangle$çš„é‰´é¢‘å™¨äº†ã€‚è¯¥é‰´é¢‘å™¨æŽ¥å—åœ¨IQå¹³é¢ä¸­meas_level=1æ—¶çš„æ•°æ®å¹¶å°†å…¶åˆ†ç±»ä¸ºæ€$|0\rangle$å’Œæ€$|1\rangle$ã€‚

æ€$|0\rangle$å’Œæ€$|1\rangle$åœ¨IQå¹³é¢ä¸­æ‰€å½¢æˆçš„ç›¸å¹²åœ†å½¢"æ–‘ç‚¹"ç§°ä¸ºè´¨å¿ƒï¼ˆcentroidï¼‰ã€‚è´¨å¿ƒçš„ä¸­å¿ƒå®šä¹‰äº†æ¯ä¸ªçŠ¶æ€çš„ç²¾ç¡®ä¸”æ— å™ªå£°çš„IQç‚¹ã€‚å›´ç»•åœ¨å‘¨å›´çš„äº‘ç»™å‡ºäº†æ•°æ®çš„æ–¹å·®ï¼Œè¯¥æ–¹å·®æ˜¯ç”±å„ç§å™ªå£°æºæ‰€ç”Ÿæˆã€‚

æˆ‘ä»¬å°†ä¼šåº”ç”¨ä¸€ç§æœºå™¨å­¦ä¹ çš„æŠ€æœ¯------çº¿æ€§åˆ¤åˆ«åˆ†æžï¼ˆLinear Discriminant
Analysisï¼ŒLDAï¼‰æ¥åŒºåˆ†æ€$|0\rangle$å’Œæ€$|1\rangle$ã€‚

é¦–å…ˆéœ€è¦èŽ·å–è´¨å¿ƒçš„æ•°æ®ï¼Œä¸ºæ­¤æˆ‘ä»¬å®šäº†ä¸¤ä¸ªè°ƒåº¦ï¼ˆå›žæƒ³ä¸€ä¸‹ä»Žæ€$|0\rangle$å¼€å§‹çš„ç³»ç»Ÿï¼‰ï¼š

1\. ç›´æŽ¥æµ‹é‡æ€$|0\rangle$ï¼ŒèŽ·å–æ€$|0\rangle$çš„è´¨å¿ƒã€‚

2\. æ–½åŠ ä¸€ä¸ª$\pi$è„‰å†²åŽæµ‹é‡å¹¶èŽ·å–æ€$|1\rangle$çš„è´¨å¿ƒã€‚

> \# Create the two schedules
>
> \# Ground state schedule
>
> zero_schedule = pulse.Schedule(name=\"zero schedule\")
>
> zero_schedule \|= measure
>
> \# Excited state schedule
>
> one_schedule = pulse.Schedule(name=\"one schedule\")
>
> one_schedule \|= pi_pulse_01(drive_chan)
>
> one_schedule \|= measure \<\< one_schedule.duration
>
> \# Assemble the schedules into a program
>
> IQ_01_program = assemble(\[zero_schedule, one_schedule\],
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'single\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\] \* 2)
>
> IQ_01_job = backend.run(IQ_01_program)
>
> print(IQ_01_job.job_id())
>
> job_monitor(IQ_01_job)
>
> è¾“å‡ºï¼š
>
> 5e8d9dffff553c0012179aae
>
> Job Status: job has successfully run
>
> \# Get job data (single); split for zero and one
>
> IQ_01_data = get_job_data(IQ_01_job, average=False)
>
> zero_data = IQ_01_data\[0\]
>
> one_data = IQ_01_data\[1\]
>
> def IQ_01_plot(x_min, x_max, y_min, y_max):
>
> \"\"\"Helper function for plotting IQ plane for \|0\>, \|1\>. Limits
> of plot given
>
> as arguments.\"\"\"
>
> \# zero data plotted in blue
>
> plt.scatter(np.real(zero_data), np.imag(zero_data),
>
> s=5, cmap=\'viridis\', c=\'blue\', alpha=0.5,
> label=r\'\$\|0\\rangle\$\')
>
> \# one data plotted in red
>
> plt.scatter(np.real(one_data), np.imag(one_data),
>
> s=5, cmap=\'viridis\', c=\'red\', alpha=0.5,
> label=r\'\$\|1\\rangle\$\')
>
> \# Plot a large dot for the average result of the zero and one states.
>
> mean_zero = np.mean(zero_data) \# takes mean of both real and
> imaginary parts
>
> mean_one = np.mean(one_data)
>
> plt.scatter(np.real(mean_zero), np.imag(mean_zero),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.scatter(np.real(mean_one), np.imag(mean_one),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.xlim(x_min, x_max)
>
> plt.ylim(y_min,y_max)
>
> plt.legend()
>
> plt.ylabel(\'I \[a.u.\]\', fontsize=15)
>
> plt.xlabel(\'Q \[a.u.\]\', fontsize=15)
>
> plt.title(\"0-1 discrimination\", fontsize=15)
>
> x_min = -5
>
> x_max = 15
>
> y_min = -5
>
> y_max = 10
>
> IQ_01_plot(x_min, x_max, y_min, y_max)

æ‰€æ˜¾ç¤ºçš„IQå›¾ä¸­è“è‰²è´¨å¿ƒä¸ºæ€$|0\rangle$ï¼Œçº¢è‰²è´¨å¿ƒä¸ºæ€$|1\rangle$ã€‚

**æ³¨ï¼šå¦‚æžœç»˜å›¾ä¸æ­£ç¡®ï¼Œè¯·é‡æ–°è¿è¡Œè¯¥notebookã€‚**

![](pics/media/image355.png)

è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç²¾ç¡®çš„æž„å»ºé‰´é¢‘å™¨äº†ã€‚æ­£å¦‚ä¸Šæ–‡ä¸­æ‰€è¿°ï¼Œæˆ‘ä»¬å°†ä¼šç”¨åˆ°ä¸€ç§åä¸º"çº¿æ€§åˆ¤åˆ«åˆ†æžï¼ˆLDAï¼‰"çš„æœºå™¨å­¦ä¹ æŠ€æœ¯ã€‚é€šè¿‡æœ€å¤§åŒ–æ¯ä¸ªç±»åˆ«çš„å‡å€¼ä¹‹é—´çš„è·ç¦»å¹¶æœ€å°åŒ–æ¯ä¸ªç±»åˆ«å†…çš„æ–¹å·®ï¼ŒLDAå¯å°†ä»»æ„æ•°æ®é›†åˆ’åˆ†ä¸ºä¸€ç»„ç±»åˆ«ï¼Œæ­¤å¤„ä¸ºæ€$|0\rangle$å’Œ$|1\rangle$ã€‚è¯¦ç»†ä¿¡æ¯è¯·å‚é˜…\[3\]ã€‚

LDAä¼šç”Ÿæˆç§°ä¸ºåˆ†ç•Œçº¿çš„ä¸€æ¡çº¿ã€‚ä¾æ®ç»™å®šæ•°æ®ç‚¹åœ¨åˆ†ç•Œçº¿çš„å“ªä¸€ä¾§ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šå…¶å±žäºŽå“ªä¸ªç±»åˆ«ã€‚åœ¨æœ¬ç¤ºä¾‹ä¸­ï¼Œåˆ†éš”çº¿çš„ä¸€ä¾§å¯¹åº”äºŽæ€$|0\rangle$ï¼Œå¦ä¸€ä¾§å¯¹åº”äºŽæ€$|1\rangle$ã€‚

æˆ‘ä»¬å°†ä¼šä½¿ç”¨æ‰€å¾—çš„ä¸€åŠæ•°æ®æ¥è®­ç»ƒæ¨¡åž‹ï¼Œç„¶åŽç”¨å¦ä¸€åŠè¿›è¡Œæµ‹è¯•ã€‚æ­¤å¤„ä½¿ç”¨scikit.learnæ¥å®žçŽ°LDAï¼›åœ¨ä»¥åŽçš„Qiskitç‰ˆæœ¬ä¸­æ­¤åŠŸèƒ½å°†ç›´æŽ¥æ·»åŠ åˆ°æ¨¡å—[Qiskit-Ignis](https://github.com/Qiskit/qiskit-ignis/tree/master/qiskit/ignis/measurement/discriminator)ã€‚

é¦–å…ˆï¼Œå°†ç»“æžœæ•°æ®é‡å¡‘ä¸ºé€‚åˆåŒºåˆ†çš„æ ¼å¼ã€‚

> def reshape_complex_vec(vec):
>
> \"\"\"Take in complex vector vec and return 2d array w/ real, imag
> entries. This is needed for the learning.
>
> Args:
>
> vec (list): complex vector of data
>
> Returns:
>
> list: vector w/ entries given by (real(vec\], imag(vec))
>
> \"\"\"
>
> length = len(vec)
>
> vec_reshaped = np.zeros((length, 2))
>
> for i in range(len(vec)):
>
> vec_reshaped\[i\]=\[np.real(vec\[i\]), np.imag(vec\[i\])\]
>
> return vec_reshaped
>
> \# Create IQ vector (split real, imag parts)
>
> zero_data_reshaped = reshape_complex_vec(zero_data)
>
> one_data_reshaped = reshape_complex_vec(one_data)
>
> IQ_01_data = np.concatenate((zero_data_reshaped, one_data_reshaped))
>
> print(IQ_01_data.shape) \# verify IQ data shape
>
> è¾“å‡ºï¼š
>
> ï¼ˆ2048ï¼Œ2ï¼‰

ç„¶åŽï¼Œå°†é‡å¡‘åŽçš„æ•°æ®åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†ã€‚ä¸ºäº†å¾—åˆ°é¢„æœŸçš„æ•ˆæžœï¼Œæ­¤å¤„ä½¿ç”¨æ€å‘é‡è¿›è¡Œæµ‹è¯•ï¼Œæ•°ç»„ä¸­çš„0ä¸ºåŸºæ€è°ƒåº¦ï¼Œ1ä¸ºæ¿€å‘è°ƒåº¦ã€‚

> \# construct vector w/ 0\'s and 1\'s (for testing)
>
> state_01 = np.zeros(NUM_SHOTS) \# shots gives number of experiments
>
> state_01 = np.concatenate((state_01, np.ones(NUM_SHOTS)))
>
> print(len(state_01))
>
> \# Shuffle and split data into training and test sets
>
> IQ_01_train, IQ_01_test, state_01_train, state_01_test =
> train_test_split(IQ_01_data, state_01, test_size=0.5)
>
> è¾“å‡ºï¼š
>
> 2048

æœ€åŽï¼Œå»ºç«‹æ¨¡åž‹å¹¶è¿›è¡Œè®­ç»ƒã€‚ä¸‹é¢çš„ä»£ç ç”¨äºŽæ‰“å°å‡ºæ‹Ÿåˆç²¾åº¦ã€‚

> \# Set up the LDA
>
> LDA_01 = LinearDiscriminantAnalysis()
>
> LDA_01.fit(IQ_01_train, state_01_train)
>
> è¾“å‡ºï¼š
>
> LinearDiscriminantAnalysis(n_components=None, priors=None,
> shrinkage=None,
>
> solver=\'svd\', store_covariance=False, tol=0.0001)
>
> \# test on some simple data
>
> print(LDA_01.predict(\[\[0,0\], \[10, 0\]\]))
>
> è¾“å‡ºï¼š
>
> \[0. 1.\]
>
> \# Compute accuracy
>
> score_01 = LDA_01.score(IQ_01_test, state_01_test)
>
> print(score_01)
>
> è¾“å‡ºï¼š
>
> 0.927734375

æœ€åŽä¸€æ­¥æ˜¯ç”»å‡ºåˆ†ç•Œçº¿ã€‚

> \# Plot separatrix on top of scatter
>
> def separatrixPlot(lda, x_min, x_max, y_min, y_max, shots):
>
> nx, ny = shots, shots
>
> xx, yy = np.meshgrid(np.linspace(x_min, x_max, nx),
>
> np.linspace(y_min, y_max, ny))
>
> Z = lda.predict_proba(np.c\_\[xx.ravel(), yy.ravel()\])
>
> Z = Z\[:, 1\].reshape(xx.shape)
>
> plt.contour(xx, yy, Z, \[0.5\], linewidths=2., colors=\'black\')
>
> IQ_01_plot(x_min, x_max, y_min, y_max)
>
> separatrixPlot(LDA_01, x_min, x_max, y_min, y_max, NUM_SHOTS)

![](pics/media/image356.png)

å¯ä»¥çœ‹åˆ°åˆ†éš”çº¿çš„æ¯ä¸€ä¾§å¯¹åº”äºŽæŸä¸€çŠ¶æ€çš„è´¨å¿ƒã€‚ç»™å®šIQå¹³é¢ä¸­çš„ä¸€ä¸ªç‚¹ï¼Œè¯¥æ¨¡åž‹å°†æ£€æŸ¥å…¶ä½äºŽåˆ†éš”çº¿çš„å“ªä¸€ä¾§å¹¶è¿”å›žç›¸åº”çš„çŠ¶æ€ã€‚

### åŒºåˆ†æ€0ã€æ€1å’Œæ€2

ç»è¿‡ä¸Šè¿°çš„æ­¥éª¤ï¼Œæˆ‘ä»¬å·²ç»æ ¡å‡†äº†$0/1$é‰´é¢‘å™¨ï¼ŒæŽ¥ç€å°±éœ€è¦æ¿€å‘æ›´é«˜çš„èƒ½æ€äº†ã€‚å…·ä½“ä¸ºï¼šæ¿€å‘æ€$|2\rangle$å¹¶ä¾æ®æ€$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$æ‰€å¯¹åº”çš„IQæ•°æ®æž„å»ºé‰´é¢‘å™¨ã€‚å¯¹äºŽæ›´é«˜çš„èƒ½æ€å¦‚$|3\rangle$ç­‰è¿™ä¸€è¿‡ç¨‹åŒæ ·é€‚ç”¨ï¼Œæœ¬æ–‡ä¸­å°±ä¸å†ç´¯è¿°ã€‚

æž„å»ºæ›´é«˜èƒ½æ€é‰´é¢‘å™¨çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š

1.  è®¡ç®—$1 \rightarrow 2$çš„é¢‘çŽ‡

2.  å®žæ–½Rabiå®žéªŒæ¥èŽ·å–$1 \rightarrow 2$çš„$\pi$è„‰å†²å¹…å€¼ã€‚ä¸ºäº†å®žçŽ°è¿™ä¸€æ­¥éª¤ï¼Œé¦–å…ˆéœ€è¦æ–½åŠ ä¸€ä¸ª$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œä½¿å¾—æ€$|0\rangle$è½¬æ¢ä¸ºæ€$|1\rangle$ã€‚ç„¶åŽï¼Œé€šè¿‡é¢‘çŽ‡æ‰«æèŽ·å–ä½¿å¾—$1 \rightarrow 2$é¢‘çŽ‡çš„é©±åŠ¨å¹…

3.  å®žæ–½3ä¸ªè°ƒåº¦ï¼š

    a.  0è°ƒåº¦ï¼ˆZero scheduleï¼‰ï¼šä»…æµ‹é‡åŸºæ€ã€‚

    b.  1è°ƒåº¦ï¼ˆOne
        > scheduleï¼‰ï¼šæ–½åŠ ä¸€ä¸ª$\pi$è„‰å†²ä½¿å¾—$0 \rightarrow 1$å¹¶æµ‹é‡ã€‚

    c.  2è°ƒåº¦ï¼ˆTwo
        > scheduleï¼‰ï¼šæ–½åŠ ä¸€ä¸ª$\pi$è„‰å†²ä½¿å¾—$0 \rightarrow 1$åŽæ–½åŠ å¦ä¸€ä¸ª$\pi$è„‰å†²ä½¿å¾—$1 \rightarrow 2$ï¼Œç„¶åŽæµ‹é‡ã€‚

4.  å°†æ¯ä¸ªè°ƒåº¦çš„æ•°æ®åˆ’åˆ†ä¸ºè®­ç»ƒé›†å’Œæµ‹è¯•é›†ï¼Œç„¶åŽä¸ºé‰´é¢‘å™¨åˆ›å»ºä¸€ä¸ªLDAæ¨¡åž‹ã€‚

#### 2.1 è®¡ç®—ä½¿å¾—$\mathbf{1 \rightarrow 2}$çš„é¢‘çŽ‡

æ ¡å‡†çš„ç¬¬ä¸€æ­¥æ˜¯è®¡ç®—ä»Ž$1 \rightarrow 2$æ‰€éœ€çš„é¢‘çŽ‡ã€‚æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼š

1.  æ–½åŠ å¾ˆé«˜çš„åŠŸçŽ‡ä»ŽåŸºæ€è¿›è¡Œé¢‘çŽ‡æ‰«æã€‚å¦‚æžœæ–½åŠ çš„åŠŸçŽ‡è¶³å¤Ÿå¤§ï¼Œåˆ™åº”è§‚å¯Ÿåˆ°ä¸¤ä¸ªå³°å€¼ã€‚å…¶ä¸­çš„ä¸€ä¸ªæ˜¯åœ¨ç¬¬1èŠ‚ä¸­ä½¿å¾—$0 \rightarrow 1$çš„é¢‘çŽ‡ï¼Œå¦ä¸€ä¸ªæ˜¯ä½¿å¾—$0 \rightarrow 2$çš„é¢‘çŽ‡ã€‚å–ä¸¤è€…ä¹‹å·®å³å¯å¾—åˆ°ä½¿å¾—$1 \rightarrow 2$çš„é¢‘çŽ‡ã€‚ä½†ç”±äºŽibmq_armonkçš„æœ€å¤§é©±åŠ¨åŠŸçŽ‡ä¸º$1.0$ï¼Œä¸è¶³ä»¥çœ‹åˆ°è¿™ä¸€å˜æ¢ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ç¬¬äºŒç§æ–¹æ³•ã€‚

2.  é€šè¿‡æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²æ¥æ¿€å‘æ€$|1\rangle$ã€‚ç„¶åŽåœ¨å·²æ¿€å‘çš„æ€$|1\rangle$ç†µè¿›è¡Œé¢‘çŽ‡æ‰«æã€‚åº”èƒ½åœ¨ä½ŽäºŽä½¿å¾—$0 \rightarrow 1$çš„é¢‘çŽ‡ä¸‹è§‚å¯Ÿåˆ°ä½¿å¾—$1 \rightarrow 2$é¢‘çŽ‡çš„ä¸€ä¸ªå³°å€¼ã€‚

##### 2.1.1 ä½¿ç”¨è¾¹å¸¦æ³•å¯¹$\mathbf{1 \rightarrow 2}$è¿‡ç¨‹è¿›è¡Œé¢‘çŽ‡æ‰«æ

æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¦ä½¿ç”¨ä¸Šè¿°çš„ç¬¬äºŒç§æ–¹æ³•ã€‚ä¸ºäº†é©±åŠ¨ä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œéœ€è¦æœ¬åœ°æŒ¯è¡å™¨(Local
Oscillator
ï¼ŒLO)çš„é¢‘çŽ‡ç”±æ ¡å‡†$0 \rightarrow 1$é¢‘çŽ‡çš„cal_qubit_freqç»™å‡ºï¼ˆå¯åœ¨ç¬¬ä¸€èŠ‚ä¸­çœ‹åˆ°Rabi
$\pi$è„‰å†²çš„æž„å»ºè¿‡ç¨‹ï¼‰ã€‚è‹¥è¦æ‰«æ$1 \rightarrow 2$é¢‘çŽ‡èŒƒå›´å°±éœ€è¦æ”¹å˜LOé¢‘çŽ‡ã€‚ä½†æ˜¯ï¼Œè„‰å†²è§„èŒƒè¦æ±‚æ¯ä¸€è°ƒåº¦åªæœ‰ä¸€ä¸ªLOé¢‘çŽ‡ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å°†LOé¢‘çŽ‡è®¾ç½®ä¸ºcal_qubit_freqï¼Œå¹¶å°†æ­£å¼¦å‡½æ•°ä¹˜ä»¥freq-cal_qubit_freqçš„$1 \rightarrow 2$è„‰å†²ï¼Œå…¶ä¸­freqæ˜¯æ‰€éœ€çš„æ‰«æé¢‘çŽ‡ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œæ–½åŠ æ­£å¼¦è¾¹å¸¦ä½¿æˆ‘ä»¬èƒ½å¤Ÿæ›´æ”¹LOé¢‘çŽ‡ï¼Œè€Œæ— éœ€åœ¨å°è£…ç¨‹åºæ—¶æ‰‹åŠ¨è®¾ç½®ã€‚

> def apply_sideband(pulse, freq):
>
> \"\"\"Apply a sinusoidal sideband to this pulse at frequency freq.
>
> Args:
>
> pulse (SamplePulse): The pulse of interest.
>
> freq (float): LO frequency for which we want to apply the sweep.
>
> Return:
>
> SamplePulse: Pulse with a sideband applied (oscillates at difference
> between freq and cal_qubit_freq).
>
> \"\"\"
>
> \# time goes from 0 to dt\*drive_samples, sine arg of form 2\*pi\*f\*t
>
> t_samples = np.linspace(0, dt\*drive_samples, drive_samples)
>
> sine_pulse = np.sin(2\*np.pi\*(freq-cal_qubit_freq)\*t_samples) \# no
> amp for the sine
>
> \# create sample pulse w/ sideband applied
>
> \# Note: need to make sq_pulse.samples real, multiply elementwise
>
> sideband_pulse = SamplePulse(np.multiply(np.real(pulse.samples),
> sine_pulse), name=\'sideband_pulse\')
>
> return sideband_pulse

æŠŠä¸Šè¿°é€»è¾‘è¿‡ç¨‹å°è£…åœ¨ä¸€ä¸ªæ–¹æ³•ä¸­ï¼Œç„¶åŽè¿è¡Œè¯¥ç¨‹åºã€‚

> def create_excited_freq_sweep_program(freqs, drive_power):
>
> \"\"\"Builds a program that does a freq sweep by exciting the \|1\>
> state.
>
> This allows us to obtain the 1-\>2 frequency. We get from the \|0\> to
> \|1\>
>
> state via a pi pulse using the calibrated qubit frequency. To do the
>
> frequency sweep from \|1\> to \|2\>, we use a sideband method by
> tacking
>
> a sine factor onto the sweep drive pulse.
>
> Args:
>
> freqs (np.ndarray(dtype=float)): Numpy array of frequencies to sweep.
>
> drive_power (float) : Value of drive amplitude.
>
> Raises:
>
> ValueError: Thrown if use more than 75 frequencies; currently, an
> error will be thrown on the backend
>
> if you try more than 75 frequencies.
>
> Returns:
>
> Qobj: Program for freq sweep experiment.
>
> \"\"\"
>
> if len(freqs) \> 75:
>
> raise ValueError(\"You can only run 75 schedules at a time.\")
>
> print(f\"The frequency sweep will go from {freqs\[0\] / GHz} GHz to
> {freqs\[-1\]/ GHz} GHz \\
>
> using {len(freqs)} frequencies. The drive power is {drive_power}.\")
>
> base_12_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_power,
>
> name=\'base_12_pulse\')
>
> schedules = \[\]
>
> for jj, freq in enumerate(freqs):
>
> \# add sideband to gaussian pulse
>
> freq_sweep_12_pulse = apply_sideband(base_12_pulse, freq)
>
> \# add commands to schedule
>
> schedule = pulse.Schedule(name=\"Frequency = {}\".format(freq))
>
> \# Add 0-\>1 pulse, freq sweep pulse and measure
>
> schedule \|= pi_pulse_01(drive_chan)
>
> schedule \|= freq_sweep_12_pulse(drive_chan) \<\< schedule.duration
>
> schedule \|= measure \<\< schedule.duration \# shift measurement to
> after drive pulses
>
> schedules.append(schedule)
>
> num_freqs = len(freqs)
>
> \# draw a schedule
>
> display(schedules\[-1\].draw(channels_to_plot=\[drive_chan,
> meas_chan\], label=True, scaling=1.0))
>
> \# assemble freq sweep program
>
> \# Note: LO is at cal_qubit_freq for each schedule; accounted for by
> sideband
>
> excited_freq_sweep_program = assemble(schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\]
>
> \* num_freqs)
>
> return excited_freq_sweep_program
>
> \# sweep 400 MHz below 0-\>1 frequency to catch the 1-\>2 frequency
>
> num_freqs = 75
>
> excited_sweep_freqs = cal_qubit_freq + np.linspace(-400\*MHz, 30\*MHz,
> num_freqs)
>
> excited_freq_sweep_program =
> create_excited_freq_sweep_program(excited_sweep_freqs,
> drive_power=0.3)
>
> \# Plot an example schedule to make sure it\'s valid
>
> è¾“å‡ºï¼š
>
> The frequency sweep will go from 4.574309813098239 GHz to
> 5.004309813098239 GHz using 75 frequencies. The drive power is 0.3.

![](pics/media/image357.png)

> excited_freq_sweep_job = backend.run(excited_freq_sweep_program)
>
> print(excited_freq_sweep_job.job_id())
>
> job_monitor(excited_freq_sweep_job)
>
> è¾“å‡ºï¼š
>
> 5e8da0965c27d000137e9587
>
> Job Status: job has successfully run
>
> \# Get job data (avg)
>
> excited_freq_sweep_data = get_job_data(excited_freq_sweep_job,
> average=True)
>
> \# Note: we are only plotting the real part of the signal
>
> plt.scatter(excited_sweep_freqs/GHz, excited_freq_sweep_data,
> color=\'black\')
>
> plt.xlim(\[min(excited_sweep_freqs/GHz)+0.01,
> max(excited_sweep_freqs/GHz)\]) \# ignore min point (is off)
>
> plt.xlabel(\"Frequency \[GHz\]\", fontsize=15)
>
> plt.ylabel(\"Measured Signal \[a.u.\]\", fontsize=15)
>
> plt.title(\"1-\>2 Frequency Sweep (first pass)\", fontsize=15)
>
> plt.show()

![](pics/media/image358.png)

å¯ä»¥çœ‹åˆ°æœ€å°å€¼åœ¨4.64GHzé™„è¿‘ã€‚æœ‰ä¸€äº›è™šå‡æœ€å¤§å€¼ï¼Œä½†å› å…¶è¿‡å¤§ï¼Œæ— æ³•è¾¾åˆ°ä½¿å¾—$1 \rightarrow 2$çš„é¢‘çŽ‡ã€‚æœ€å°å€¼å¯¹åº”äºŽ$1 \rightarrow 2$é¢‘çŽ‡ã€‚

é€šè¿‡ç›¸å¯¹æžå°ï¼ˆrelative
minimaï¼‰å‡½æ•°å¯ä»¥ç²¾ç¡®è®¡ç®—è¯¥ç‚¹çš„å€¼ã€‚è¿™æ ·å°±å¯ä»¥ä¼°ç®—å‡º$1 \rightarrow 2$çš„é¢‘çŽ‡ã€‚

> \# Prints out relative minima frequencies in output_data; height gives
> lower bound (abs val)
>
> def rel_minima(freqs, output_data, height):
>
> \"\"\"
>
> Prints out relative minima frequencies in output_data (can see peaks);
> height gives upper bound (abs val).
>
> Be sure to set the height properly or the peak will be ignored!
>
> Args:
>
> freqs (list): frequency list
>
> output_data (list): list of resulting signals
>
> height (float): upper bound (abs val) on a peak
>
> Returns:
>
> list: List containing relative minima frequencies
>
> \"\"\"
>
> peaks, \_ = find_peaks(-1\*output_data, height)
>
> print(\"Freq. dips: \", freqs\[peaks\])
>
> return freqs\[peaks\]
>
> minima = rel_minima(excited_sweep_freqs,
> np.real(excited_freq_sweep_data), 10)
>
> approx_12_freq = minima\[0\]
>
> è¾“å‡ºï¼š
>
> Freq. dips: \[4.62660711e+09\]

çŽ°åœ¨ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸Šé¢èŽ·å¾—çš„ä¼°è®¡å€¼ï¼ˆè¾ƒå°çš„èŒƒå›´ï¼‰è¿›è¡Œç²¾ç¡®æ‰«æã€‚è¿™å°†è®©æˆ‘ä»¬èŽ·å¾—ä½¿å¾—$1 \rightarrow 2$æ›´å‡†ç¡®çš„é¢‘çŽ‡å€¼ã€‚åœ¨æ¯ä¸ªæ–¹å‘ä¸Šä»¥20MHzæ‰«æã€‚

> \# smaller range refined sweep
>
> num_freqs = 75
>
> refined_excited_sweep_freqs = approx_12_freq + np.linspace(-20\*MHz,
> 20\*MHz, num_freqs)
>
> refined_excited_freq_sweep_program =
> create_excited_freq_sweep_program(refined_excited_sweep_freqs,
> drive_power=0.3)
>
> è¾“å‡ºï¼š
>
> The frequency sweep will go from 4.606607110395537 GHz to
> 4.646607110395537 GHz using 75 frequencies. The drive power is 0.3.

![](pics/media/image359.png)

> refined_excited_freq_sweep_job =
> backend.run(refined_excited_freq_sweep_program)
>
> print(refined_excited_freq_sweep_job.job_id())
>
> job_monitor(refined_excited_freq_sweep_job)
>
> è¾“å‡ºï¼š
>
> 5e8da1283ab1aa0011fd1772
>
> Job Status: job has successfully run
>
> \# Get the refined data (average)
>
> refined_excited_freq_sweep_data =
> get_job_data(refined_excited_freq_sweep_job, average=True)

ä½¿ç”¨æ ‡å‡†æ´›ä¼¦å…¹æ›²çº¿æ‹Ÿåˆç²¾ç¡®ä¿¡å·ã€‚

> \# do fit in Hz
>
> (refined_excited_sweep_fit_params,
>
> refined_excited_sweep_y\_fit) =
> fit_function(refined_excited_sweep_freqs,
>
> refined_excited_freq_sweep_data,
>
> lambda x, A, q_freq, B, C: (A / np.pi) \* (B / ((x - q_freq)\*\*2 +
> B\*\*2)) + C,
>
> \[-12, 4.625\*GHz, 0.05\*GHz, 3\*GHz\] \# initial parameters for
> curve_fit
>
> )
>
> \# Note: we are only plotting the real part of the signal
>
> plt.scatter(refined_excited_sweep_freqs/GHz,
> refined_excited_freq_sweep_data, color=\'black\')
>
> plt.plot(refined_excited_sweep_freqs/GHz,
> refined_excited_sweep_y\_fit, color=\'red\')
>
> plt.xlim(\[min(refined_excited_sweep_freqs/GHz),
> max(refined_excited_sweep_freqs/GHz)\])
>
> plt.xlabel(\"Frequency \[GHz\]\", fontsize=15)
>
> plt.ylabel(\"Measured Signal \[a.u.\]\", fontsize=15)
>
> plt.title(\"1-\>2 Frequency Sweep (refined pass)\", fontsize=15)
>
> plt.show()

![](pics/media/image360.png)

> \_, qubit_12_freq, \_, \_ = refined_excited_sweep_fit_params
>
> print(f\"Our updated estimate for the 1-\>2 transition frequency is \"
>
> f\"{round(qubit_12_freq/GHz, 7)} GHz.\")
>
> è¾“å‡ºï¼š
>
> Our updated estimate for the 1-\>2 transition frequency is 4.6261106
> GHz.

#### 2.2 æ€1-\>æ€2 Rabiå®žéªŒ

ç»è¿‡ä¸Šè¿°çš„æ­¥éª¤ï¼Œæˆ‘ä»¬å¯¹ä½¿å¾—$1 \rightarrow 2$çš„é¢‘çŽ‡æœ‰äº†ä¸€ä¸ªå¾ˆå¥½çš„ä¼°è®¡ï¼ŒçŽ°åœ¨å®žæ–½Rabiå®žéªŒæ¥èŽ·å¾—ä½¿å¾—$1 \rightarrow 2$çš„$\pi$è„‰å†²å¹…å€¼ã€‚ä¸ºæ­¤ï¼Œéœ€è¦æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œç„¶åŽè¿ç”¨è¾¹å¸¦æ–¹æ³•ä»¥ä½¿å¾—$1 \rightarrow 2$çš„é¢‘çŽ‡æ‰«æé©±åŠ¨å¹…å€¼ã€‚

> \# experimental configuration
>
> num_rabi_points = 75 \# number of experiments (ie amplitudes to sweep
> out)
>
> \# Drive amplitude values to iterate over: 75 amplitudes evenly spaced
> from 0 to 1.0
>
> drive_amp_min = 0
>
> drive_amp_max = 1.0
>
> drive_amps = np.linspace(drive_amp_min, drive_amp_max,
> num_rabi_points)
>
> \# Create schedule
>
> rabi_12_schedules = \[\]
>
> \# loop over all drive amplitudes
>
> for ii, drive_amp in enumerate(drive_amps):
>
> base_12_pulse = pulse_lib.gaussian(duration=drive_samples,
>
> sigma=drive_sigma,
>
> amp=drive_amp,
>
> name=\'base_12_pulse\')
>
> \# apply sideband at the 1-\>2 frequency
>
> rabi_12_pulse = apply_sideband(base_12_pulse, qubit_12_freq)
>
> \# add commands to schedule
>
> schedule = pulse.Schedule(name=\'Rabi Experiment at drive amp = %s\' %
> drive_amp)
>
> schedule \|= pi_pulse_01(drive_chan) \# 0-\>1
>
> schedule \|= rabi_12_pulse(drive_chan) \<\< schedule.duration \# 1-\>2
> Rabi pulse
>
> schedule \|= measure \<\< schedule.duration \# shift measurement to
> after drive pulse
>
> rabi_12_schedules.append(schedule)
>
> \# Assemble the schedules into a program
>
> \# Note: The LO frequency is at cal_qubit_freq to support the 0-\>1 pi
> pulse;
>
> \# it is modified for the 1-\>2 pulse using sidebanding
>
> rabi_12_expt_program = assemble(rabi_12_schedules,
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'avg\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\]
>
> \* num_rabi_points)
>
> rabi_12_job = backend.run(rabi_12_expt_program)
>
> print(rabi_12_job.job_id())
>
> job_monitor(rabi_12_job)
>
> è¾“å‡ºï¼š
>
> 5e8da3a1ff553c0012179ade
>
> Job Status: job has successfully run
>
> \# Get the job data (average)
>
> rabi_12_data = get_job_data(rabi_12_job, average=True)

ç»˜åˆ¶å¹¶æ‹Ÿåˆæ•°æ®ã€‚

> \# Note: We only plot the real part of the signal.
>
> rabi_12_data = np.real(baseline_remove(rabi_12_data))
>
> (rabi_12_fit_params,
>
> rabi_12_y\_fit) = fit_function(drive_amps,
>
> rabi_12_data,
>
> lambda x, A, B, drive_12_period, phi:
> (A\*np.cos(2\*np.pi\*x/drive_12_period - phi) + B),
>
> \[3, 0.5, 0.9, 0\])
>
> plt.scatter(drive_amps, rabi_12_data, color=\'black\')
>
> plt.plot(drive_amps, rabi_12_y\_fit, color=\'red\')
>
> drive_12_period = rabi_12_fit_params\[2\]
>
> \# account for phi in computing pi amp
>
> pi_amp_12 = (drive_12_period/2/np.pi)
> \*(np.pi+rabi_12_fit_params\[3\])
>
> plt.axvline(pi_amp_12, color=\'red\', linestyle=\'\--\')
>
> plt.axvline(pi_amp_12+drive_12_period/2, color=\'red\',
> linestyle=\'\--\')
>
> plt.annotate(\"\", xy=(pi_amp_12+drive_12_period/2, 0),
> xytext=(pi_amp_12,0), arrowprops=dict(arrowstyle=\"\<-\>\",
> color=\'red\'))
>
> plt.annotate(\"\$\\pi\$\", xy=(pi_amp_12-0.03, 0.1), color=\'red\')
>
> plt.xlabel(\"Drive amp \[a.u.\]\", fontsize=15)
>
> plt.ylabel(\"Measured signal \[a.u.\]\", fontsize=15)
>
> plt.title(\'Rabi Experiment (1-\>2)\', fontsize=20)
>
> plt.show()

![](pics/media/image361.png)

> print(f\"Our updated estimate for the 1-\>2 transition frequency is \"
>
> f\"{round(qubit_12_freq/GHz, 7)} GHz.\")
>
> print(f\"Pi Amplitude (1-\>2) = {pi_amp_12}\")
>
> è¾“å‡ºï¼š
>
> Our updated estimate for the 1-\>2 transition frequency is 4.6263002
> GHz.
>
> Pi Amplitude (1-\>2) = 0.37256049920143336

é€šè¿‡æ­¤ä¿¡æ¯ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä½¿å¾—$1 \rightarrow 2$çš„$\pi$è„‰å†²ï¼ˆç¡®ä¿åœ¨ä½¿å¾—$1 \rightarrow 2$çš„é¢‘çŽ‡ä¸Šæ·»åŠ è¾¹å¸¦ï¼‰ã€‚

> pi_pulse_12 = pulse_lib.gaussian(duration=drive_samples,
>
> amp=pi_amp_12,
>
> sigma=drive_sigma,
>
> name=\'pi_pulse_12\')
>
> \# make sure this pulse is sidebanded
>
> pi_pulse_12 = apply_sideband(pi_pulse_12, qubit_12_freq)

#### 2.3 æž„å»ºåŒºæ€0ã€1åŠ2çš„é‰´é¢‘å™¨

æœ€åŽï¼Œä¸ºåŒºåˆ†$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$æž„å»ºé‰´é¢‘å™¨ã€‚è¯¥è¿‡ç¨‹ä¸Žç¬¬1èŠ‚ä¸­æ‰€è¿°é¡¹ç±»ä¼¼ï¼Œä½†æ­¤å¤„æˆ‘ä»¬ä¸º$|2\rangle$æ·»åŠ äº†ä¸€ä¸ªé™„åŠ è°ƒåº¦ã€‚

å›žé¡¾ä¸€ä¸‹ä¸‰ä¸ªè°ƒåº¦ï¼ˆä»Ž$|0\rangle$å¼€å§‹ï¼‰ï¼š

1\. é€šè¿‡ç›´æŽ¥æµ‹é‡$|0\rangle$èŽ·å–$|0\rangle$çš„è´¨å¿ƒã€‚

2\.
æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²ï¼Œç„¶åŽé€šè¿‡æµ‹é‡æ¥èŽ·å–$|1\rangle$çš„è´¨å¿ƒã€‚

3\.
æ–½åŠ ä¸€ä¸ªä½¿å¾—$0 \rightarrow 1$çš„$\pi$è„‰å†²åŽå†æ–½åŠ ä¸€ä¸ªä½¿å¾—$1 \rightarrow 2$çš„$\pi$è„‰å†²ï¼Œç„¶åŽé€šè¿‡æµ‹é‡æ¥èŽ·å–$|2\rangle$çš„è´¨å¿ƒã€‚

> \# Create the three schedules
>
> \# Ground state schedule
>
> zero_schedule = pulse.Schedule(name=\"zero schedule\")
>
> zero_schedule \|= measure
>
> \# Excited state schedule
>
> one_schedule = pulse.Schedule(name=\"one schedule\")
>
> one_schedule \|= pi_pulse_01(drive_chan)
>
> one_schedule \|= measure \<\< one_schedule.duration
>
> \# Excited state schedule
>
> two_schedule = pulse.Schedule(name=\"two schedule\")
>
> two_schedule \|= pi_pulse_01(drive_chan)
>
> two_schedule \|= pi_pulse_12(drive_chan) \<\< two_schedule.duration
>
> two_schedule \|= measure \<\< two_schedule.duration

æž„å»ºç¨‹åºå¹¶åœ¨IQå¹³é¢ä¸Šç»˜åˆ¶è´¨å¿ƒã€‚

> \# Assemble the schedules into a program
>
> IQ_012_program = assemble(\[zero_schedule, one_schedule,
> two_schedule\],
>
> backend=backend,
>
> meas_level=1,
>
> meas_return=\'single\',
>
> shots=NUM_SHOTS,
>
> schedule_los=\[{drive_chan: cal_qubit_freq}\] \* 3)
>
> IQ_012_job = backend.run(IQ_012_program)
>
> print(IQ_012_job.job_id())
>
> job_monitor(IQ_012_job)
>
> è¾“å‡ºï¼š
>
> 5e8da7dfecce7e0011fb14a5
>
> Job Status: job has successfully run
>
> \# Get job data (single); split for zero, one and two
>
> IQ_012_data = get_job_data(IQ_012_job, average=False)
>
> zero_data = IQ_012_data\[0\]
>
> one_data = IQ_012_data\[1\]
>
> two_data = IQ_012_data\[2\]
>
> def IQ_012_plot(x_min, x_max, y_min, y_max):
>
> \"\"\"Helper function for plotting IQ plane for 0, 1, 2. Limits of
> plot given
>
> as arguments.\"\"\"
>
> \# zero data plotted in blue
>
> plt.scatter(np.real(zero_data), np.imag(zero_data),
>
> s=5, cmap=\'viridis\', c=\'blue\', alpha=0.5,
> label=r\'\$\|0\\rangle\$\')
>
> \# one data plotted in red
>
> plt.scatter(np.real(one_data), np.imag(one_data),
>
> s=5, cmap=\'viridis\', c=\'red\', alpha=0.5,
> label=r\'\$\|1\\rangle\$\')
>
> \# two data plotted in green
>
> plt.scatter(np.real(two_data), np.imag(two_data),
>
> s=5, cmap=\'viridis\', c=\'green\', alpha=0.5,
> label=r\'\$\|2\\rangle\$\')
>
> \# Plot a large dot for the average result of the 0, 1 and 2 states.
>
> mean_zero = np.mean(zero_data) \# takes mean of both real and
> imaginary parts
>
> mean_one = np.mean(one_data)
>
> mean_two = np.mean(two_data)
>
> plt.scatter(np.real(mean_zero), np.imag(mean_zero),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.scatter(np.real(mean_one), np.imag(mean_one),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.scatter(np.real(mean_two), np.imag(mean_two),
>
> s=200, cmap=\'viridis\', c=\'black\',alpha=1.0)
>
> plt.xlim(x_min, x_max)
>
> plt.ylim(y_min,y_max)
>
> plt.legend()
>
> plt.ylabel(\'I \[a.u.\]\', fontsize=15)
>
> plt.xlabel(\'Q \[a.u.\]\', fontsize=15)
>
> plt.title(\"0-1-2 discrimination\", fontsize=15)
>
> x_min = -20
>
> x_max = 10
>
> y_min = -10
>
> y_max = 5
>
> IQ_012_plot(x_min, x_max, y_min, y_max)

![](pics/media/image362.png)

çŽ°åœ¨æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°å¯¹åº”äºŽ$|2\rangle$çš„ç¬¬ä¸‰ä¸ªè´¨å¿ƒäº†ã€‚ï¼ˆæ³¨ï¼šå¦‚æžœç»˜å›¾ä¸æ­£ç¡®ï¼Œè¯·é‡æ–°è¿è¡Œnotbookï¼‰

æœ‰äº†è¿™äº›æ•°æ®ï¼Œæˆ‘ä»¬å°±å¯ä»¥å»ºç«‹é‰´é¢‘å™¨äº†ã€‚ä¸Žä¸Šæ–‡ä¸­æ‰€è¿°çš„æ­¥éª¤ä¸€æ ·ï¼Œæ­¤å¤„è¿˜æ˜¯ä½¿ç”¨scikit.learnä»¥åŠçº¿æ€§åˆ¤åˆ«åˆ†æžï¼ˆLDAï¼‰ã€‚

é¦–å…ˆå¯¹éœ€è¦LDAçš„æ•°æ®é‡å¡‘ã€‚

> \# Create IQ vector (split real, imag parts)
>
> zero_data_reshaped = reshape_complex_vec(zero_data)
>
> one_data_reshaped = reshape_complex_vec(one_data)
>
> two_data_reshaped = reshape_complex_vec(two_data)
>
> IQ_012_data = np.concatenate((zero_data_reshaped, one_data_reshaped,
> two_data_reshaped))
>
> print(IQ_012_data.shape) \# verify IQ data shape
>
> æ•°æ®ï¼š
>
> (3072, 2)

ç„¶åŽï¼Œåˆ†å‰²è®­ç»ƒå’Œæµ‹è¯•æ•°æ®ï¼ˆä¸€åŠå¯¹ä¸€åŠï¼‰ã€‚æµ‹è¯•æ•°æ®æ˜¯ä¸€ä¸ªåŒ…å«0ï¼ˆ0è°ƒåº¦ï¼‰ï¼Œ1ï¼ˆ1è°ƒåº¦ï¼‰å’Œ2ï¼ˆ2è°ƒåº¦ï¼‰ï¼‰çš„æ•°ç»„ã€‚

> \# construct vector w/ 0\'s, 1\'s and 2\'s (for testing)
>
> state_012 = np.zeros(NUM_SHOTS) \# shots gives number of experiments
>
> state_012 = np.concatenate((state_012, np.ones(NUM_SHOTS)))
>
> state_012 = np.concatenate((state_012, 2\*np.ones(NUM_SHOTS)))
>
> print(len(state_012))
>
> \# Shuffle and split data into training and test sets
>
> IQ_012_train, IQ_012_test, state_012_train, state_012_test =
> train_test_split(IQ_012_data, state_012, test_size=0.5)
>
> è¾“å‡ºï¼š
>
> 3072

æœ€åŽï¼Œå»ºç«‹æ¨¡åž‹ã€è®­ç»ƒå¹¶æ‰“å°å‡ºæ‹Ÿåˆç²¾åº¦ã€‚

> \# Set up the LDA
>
> LDA_012 = LinearDiscriminantAnalysis()
>
> LDA_012.fit(IQ_012_train, state_012_train)
>
> è¾“å‡ºï¼š
>
> LinearDiscriminantAnalysis(n_components=None, priors=None,
> shrinkage=None,
>
> solver=\'svd\', store_covariance=False, tol=0.0001)
>
> \# test on some simple data
>
> print(LDA_012.predict(\[\[0, 0\], \[-10, 0\], \[-15, -5\]\]))
>
> è¾“å‡ºï¼š
>
> \[0. 1. 2.\]
>
> \# Compute accuracy
>
> score_012 = LDA_012.score(IQ_012_test, state_012_test)
>
> print(score_012)
>
> è¾“å‡ºï¼š
>
> 0.818359375

æœ€åŽä¸€æ­¥æ˜¯ç»˜åˆ¶åˆ†éš”çº¿ã€‚

> IQ_012_plot(x_min, x_max, y_min, y_max)
>
> separatrixPlot(LDA_012, x_min, x_max, y_min, y_max, NUM_SHOTS)

![](pics/media/image363.png)

å› ä¸ºæœ‰äº†3ä¸ªè´¨å¿ƒï¼Œæ‰€ä»¥åˆ†éš”çº¿ä¸æ˜¯ä¸€æ¡çº¿ï¼Œè€Œæ˜¯ä¸€æ¡åŒ…å«ä¸¤çº¿ç»„åˆçš„æ›²çº¿ã€‚ä¸ºäº†åŒºåˆ†$|0\rangle$ã€$|1\rangle$å’Œ$|2\rangle$ï¼Œæ¨¡åž‹ä¼šæ£€æŸ¥æŒ‡å®šIQç‚¹ç›¸å¯¹äºŽåˆ†éš”çº¿çš„ä½ç½®ï¼Œå¹¶ç›¸åº”åœ°å¯¹è¯¥ç‚¹è¿›è¡Œåˆ†ç±»ã€‚

### 3. å‚è€ƒæ–‡çŒ®

1.  D. C. McKay, T. Alexander, L. Bello, M. J. Biercuk, L. Bishop, J.
    Chen, J. M. Chow, A. D. C Ìorcoles, D. Egger, S. Filipp, J.
    Gomez, M. Hush, A. Javadi-Abhari, D. Moreda, P. Nation, B.
    Paulovicks, E. Winston, C. J. Wood, J. Wootton, and J. M. Gambetta,
    "Qiskit backend specifications for OpenQASM and OpenPulse
    experiments," 2018, <https://arxiv.org/abs/1809.03452>.

2.  Krantz, P. et al. "A Quantum Engineer's Guide to Superconducting
    Qubits." Applied Physics Reviews 6.2 (2019): 021318,
    <https://arxiv.org/abs/1904.06560>.

3.  Scikit-learn: Machine Learning in Python, Pedregosa et al., JMLR 12,
    pp. 2825-2830, 2011,
    <https://scikit-learn.org/stable/modules/lda_qda.html#id4>.

> import qiskit.tools.jupyter
>
> %qiskit_version_table

6.3 Transmonç‰©ç†ç†è®ºç®€ä»‹
------------------------

### å†…å®¹

1\. å°†å¤šèƒ½çº§é‡å­ç³»ç»Ÿä½œä¸ºé‡å­æ¯”ç‰¹

2\. é‡å­å›žè·¯çš„å“ˆå¯†é¡¿é‡

3\. é‡åŒ–å“ˆå¯†é¡¿é‡

4\. é‡åŒ–Transmon

5\. Transmonä¸Žé‡å­è°æŒ¯å­çš„æ¯”è¾ƒ

6\. é‡å­æ¯”ç‰¹é©±åŠ¨ä¸Žæ—‹è½¬æ³¢è¿‘ä¼¼

### 1. å°†å¤šèƒ½çº§é‡å­ç³»ç»Ÿä½œä¸ºé‡å­æ¯”ç‰¹

ç ”ç©¶é‡å­æ¯”ç‰¹æœ¬è´¨ä¸Šæ˜¯å­¦ä¹ åŒèƒ½çº§ç³»ç»Ÿç‰©ç†ã€‚åŒèƒ½çº§ç³»ç»Ÿçš„å…¸åž‹ç¤ºä¾‹å°±æ˜¯ç”µå­çš„è‡ªæ—‹ï¼ˆæˆ–å…¶ä»–"è‡ªæ—‹-1/2"çš„ç²’å­ï¼‰ï¼šå…¶å¯æŒ‡å‘ä¸Šæˆ–æŒ‡å‘ä¸‹ï¼Œæˆ‘ä»¬å°†å…¶åˆ†åˆ«æ ‡è®°ä¸ºæ€$|0\rangle$å’Œæ€$|1\rangle$ã€‚æ€$|0\rangle$åœ¨åŽ†å²ä¸Šè¢«å®šä¹‰ä¸ºå¸ƒæ´›èµ«çƒçš„åŒ—æžï¼ˆnorth
poleï¼‰ï¼Œå…¶åŽŸå› ä¸ºï¼šå½“ç£åœºæ–½åŠ åœ¨$+ \overset{\hat{} }{z}$æ–¹å‘ä¸Šæ—¶ï¼Œè¯¥å¤„å¤„äºŽä½Žèƒ½æ€ã€‚

å¦ä¸€ç§ç±»ä¼¼çš„åŒèƒ½çº§ç³»ç»Ÿè¢«å‘çŽ°äºŽç¬¬ä¸€ç§è¶…å¯¼é‡å­æ¯”ç‰¹------ç”µå­åº“ç€å¯¹ç®±ï¼ˆ[Cooper
Pair
Box](https://arxiv.org/pdf/cond-mat/9904003v1.pdf)ï¼‰ä¸­ã€‚è¶…å¯¼ä½“ä¸­æ²¡æœ‰ç”µé˜»çš„åŽŸå› æ˜¯ç”µå­ä»¥åº“ç€å¯¹çš„å½¢å¼ç»“åˆåœ¨ä¸€èµ·ï¼Œå…¶å¯é€šè¿‡å¸æ”¶èƒ½é‡è€Œåˆ†ç¦»å¹¶ä¸”è¿™ç§èƒ½é‡åœ¨ä½Žæ¸©ä¸‹æ— æ³•å˜ä¸ºçƒ­èƒ½ï¼Œå› æ­¤ç”µå­ä¹‹é—´èƒ½å¤Ÿæœ‰æ•ˆåœ°ç›¸äº’å¸å¼•ã€‚è¿™ä¸€æƒ…å†µæœ‰äº›è¿èƒŒç›´è§‰ï¼Œå› ä¸ºç”µå­éƒ½å¸¦è´Ÿç”µï¼Œå› è€Œä¹‹é—´åº”è¯¥äº’ç›¸æŽ’æ–¥ï¼ç„¶è€Œï¼Œåœ¨è®¸å¤šç‰©è´¨ç³»ç»Ÿä¸­æœ‰æ•ˆçš„ç›¸äº’ä½œç”¨å¯ä»¥é€šè¿‡ç¾¤ä½“æ•ˆåº”ï¼ˆcollective
effectï¼‰æ¥è°ƒèŠ‚ï¼šäººä»¬å¯ä»¥å°†ç”µå­è§†ä¸ºè¢«æ­£ç”µè·æ™¶æ ¼ä¸­çš„å…¶ä»–ç”µå­æ‰€å¸å¼•ã€‚ç”µå­åº“ç€å¯¹ç®±ç”±ä¸€ä¸ªè¶…å¯¼å²›ç»„æˆï¼Œè¯¥å²›å æ®ä¸€ä¸ªé¢å¤–çš„åº“ç€å¯¹ç”µè·$2e$ï¼ˆæ€$|0\rangle$ï¼‰æˆ–ä¸å æ®ï¼ˆæ€$|1\rangle$ï¼‰ã€‚è¿™äº›çŠ¶æ€å¯ä»¥é€šè¿‡éš§é“ç»“ä¸Šçš„ç”µåŽ‹è¿›è¡ŒæŽ§åˆ¶ï¼Œå¹¶ä¸”åœ¨"æ …æž"ç”µåŽ‹æŽ§åˆ¶ä¸‹å‘ˆçŽ°å‘¨æœŸæ€§ï¼Œå› æ­¤ç”µå­åº“ç€å¯¹ç®±ç¡®ä¸ºåŒèƒ½çº§ç³»ç»Ÿã€‚

åœ¨å°†é‡å­æ¯”ç‰¹ç¼–ç ä¸ºç”µè·çŠ¶æ€æ—¶å¯¹æ‰€å­˜åœ¨çš„ç”µè·å™ªå£°ï¼ˆ*charge
noise*ï¼‰éžå¸¸æ•æ„Ÿï¼Œå…¶ä¹Ÿå¯¹ç”µå­åº“ç€å¯¹ç®±æˆç«‹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸å—ç ”ç©¶äººå‘˜é’ççš„åŽŸå› ã€‚å¤§å¤šå…¶ä»–é‡å­ç³»ç»Ÿå¹¶éžåŒèƒ½çº§ç³»ç»Ÿï¼Œæ¯”å¦‚æ¯ä¸ªåŽŸå­éƒ½å…·æœ‰ç‹¬ç‰¹çš„è°±çº¿ï¼ˆèƒ½é‡è·ƒè¿ï¼‰ï¼Œå¤©æ–‡å­¦å®¶å°†å…¶ç”¨äºŽç¡®å®šæˆ‘ä»¬æ‰€å¤„å®‡å®™çš„æž„æˆã€‚é€šè¿‡æœ‰æ•ˆåœ°éš”ç¦»å’ŒæŽ§åˆ¶å…¶ä¸­çš„ä¸¤ä¸ªèƒ½çº§ï¼Œä¾‹å¦‚åŽŸå­çš„åŸºæ€å’Œç¬¬ä¸€æ¿€å‘æ€ï¼Œå°±å¯å°†å…¶è§†ä¸ºä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚ä½†å¦‚ä½¿ç”¨å…¶ä»–ç±»åž‹çš„è¶…å¯¼ç”µè·¯ä½œä¸ºé‡å­æ¯”ç‰¹æ˜¯ä½•æƒ…å†µå‘¢ï¼Ÿè§£å†³æ–¹æ¡ˆæ˜¯è®¾è®¡ä¸€ä¸ªå…·æœ‰é«˜é˜¶èƒ½çº§çš„é‡å­æ¯”ç‰¹å¯¹å†²ç”µå­åº“ç€å¯¹ç®±çš„ç”µè·é­å—é—®é¢˜ï¼Œè¿™ä¸€å…·æœ‰é«˜é˜¶èƒ½çº§çš„é‡å­æ¯”ç‰¹ç§°ä¸ºï¼š[transmon](https://arxiv.org/pdf/cond-mat/0703002.pdf)ï¼ˆå…¨ç§°ï¼š*transmission-line
shunted plasma oscillation*
qubitï¼‰ã€‚é€šè¿‡ç‰ºç‰²éžè°æ€§ï¼ˆ$|0\rangle \rightarrow |1\rangle$ä¸Ž$|1\rangle \rightarrow |2\rangle$è½¬æ¢é¢‘çŽ‡çš„å·®å¼‚ï¼Œè§"6.2
è®¿é—®æ›´é«˜çš„èƒ½æ€"ï¼‰ï¼Œç”µè·å™ªå£°å¾—åˆ°æŠ‘åˆ¶ï¼ŒåŒæ—¶ä»å…è®¸å°†æœ€ä½Žçš„ä¸¤ä¸ªèƒ½çº§å½“ä½œä¸€ä¸ªé‡å­æ¯”ç‰¹ã€‚åœ¨æ­¤å¤„é‡å­æ€è¢«ç¼–ç ä¸ºè·¨ä¸¤ä¸ªè¶…å¯¼å²›ä¹‹é—´éš§é“ç»“çš„åº“ç€å¯¹æŒ¯è¡ï¼Œå…¶ä¸­ç”¨äºŽæ¿€å‘æ€$|1\rangle$çš„æŒ¯è¡é¢‘çŽ‡æ¯”åŸºæ€$|0\rangle$çš„é«˜ã€‚

### 2. é‡å­å›žè·¯çš„å“ˆå¯†é¡¿é‡

å“ˆå¯†é¡¿é‡æ˜¯ä¸€ä¸ªç­‰äºŽç³»ç»Ÿæ€»èƒ½é‡ã€åŠ¿èƒ½å’ŒåŠ¨èƒ½çš„å‡½æ•°ã€‚è¿™ä¸€è§‚ç‚¹åœ¨ç»å…¸åŠ›å­¦ä¸­æ­£ç¡®ï¼Œé‡å­å“ˆå¯†é¡¿é‡è¢«å‘çŽ°äºŽé€šè¿‡å°†å˜é‡æå‡ä¸ºç®—å­æ—¶ã€‚é€šè¿‡å¯¹æ¯”ç»å…¸æ³Šæ¾æ‹¬å·ï¼ˆPoisson
Backetï¼‰ä¸Žé‡å­å¯¹æ˜“å¼ï¼ˆquantum
commutatorï¼‰ï¼Œå‘çŽ°å…¶ä¸èƒ½å¯¹æ˜“ï¼Œå› æ­¤æ— æ³•åŒæ—¶å¯¹å…¶è¿›è¡Œè§‚å¯Ÿï¼Œè¿™ä¸€ç‚¹ä¸Žæµ·æ£®å ¡ä¸ç¡®å®šæ€§åŽŸç†ç›¸åŒã€‚

é¦–å…ˆï¼Œå‡è®¾ä¸€ä¸ªçº¿æ€§$\text{LC}$ç”µè·¯ï¼Œå…¶ä¸­$L$æ˜¯ç”µæ„Ÿï¼Œ$C$æ˜¯ç”µå®¹ã€‚å“ˆå¯†é¡¿é‡æ˜¯åŠ¨èƒ½ï¼ˆç”±ç”µè·$Q$è¡¨ç¤ºï¼‰å’ŒåŠ¿èƒ½ï¼ˆç”±ï¼ˆç”µï¼‰é€šé‡$\Phi$è¡¨ç¤ºï¼‰ä¹‹å’Œï¼š

$$\mathcal{H =}\frac{Q^{2} }{2C} + \frac{\Phi^{2} }{2L}$$

**çº¿æ€§ç”µè·¯çš„åˆ†æ”¯é€šé‡æ³•(Branch-Flux Method)**

å“ˆå¯†é¡¿å‡½æ•°å’Œæ‹‰æ ¼æœ—æ—¥å‡½æ•°æ¶‰åŠå¤§è´¨é‡ç‰©ä½“çš„èƒ½é‡ï¼Œåœ¨ç»å…¸ç³»ç»Ÿçš„åŠ¨åŠ›å­¦ä¸­æœ‰ç€ä¸°å¯Œçš„åŽ†å²ã€‚å…¶ä»ä½œä¸º"é‡åŒ–"å¯¹è±¡çš„æ¨¡æ¿ï¼ŒåŒ…æ‹¬transmonã€‚è¯¥æ–¹æ³•åŒ…æ‹¬æ ¹æ®å¹¿ä¹‰åæ ‡å†™å‡ºæ‹‰æ ¼æœ—æ—¥å‡½æ•°ï¼šæˆ‘ä»¬å°†é€‰æ‹©ä¸€ä¸ªç§°ä¸ºé€šé‡ï¼ˆfluxï¼‰çš„é‡ï¼Œè¯¥é‡ç”±å¯¹ç”µåŽ‹çš„è®¤çŸ¥å®šä¹‰ï¼Œä¼ ç»Ÿä¸Šäººä»¬é€šå¸¸ä¼šé€‰æ‹©3ç»´ç©ºé—´ä¸­çš„ä½ç½®ã€‚ç„¶åŽè®¡ç®—å‡ºä¸Žå¹¿ä¹‰åæ ‡å¯¹åº”çš„å…±è½­å˜é‡ï¼Œæœ€ç»ˆå¯å°†å…¶è§†ä¸ºç”µè·chargeï¼ˆåœ¨ç»å…¸ç‰©ç†ç§°ä¸ºåŠ¨é‡momentumï¼‰ã€‚é€šè¿‡å‹’è®©å¾·å˜æ¢è®¡ç®—å‡ºå“ˆå¯†é¡¿é‡ï¼Œè¯¥å“ˆå¯†é¡¿é‡è¡¨ç¤ºç³»ç»Ÿçš„èƒ½é‡ä¹‹å’Œã€‚å¯ä»¥ä½¿ç”¨åˆ†æ”¯é€šé‡æ³•è€ƒè™‘ç”µå®¹å’Œç”µæ„Ÿèƒ½é‡æ¥æ‰¾å‡ºç”µè·¯çš„å“ˆå¯†é¡¿é‡ï¼Œæ­¤æ–¹æ³•æœ¬èº«åŸºäºŽç»å…¸æ‹‰æ ¼æœ—æ—¥åŠ›å­¦ã€‚å°†é€šé‡å’Œç”µè·åˆ†åˆ«å®šä¹‰ä¸ºç”µåŽ‹å’Œç”µæµçš„æ—¶é—´ç§¯åˆ†ï¼š

$$\Phi\left( t \right) = \int_{- \infty}^{t}{V\left( t^{'} \right)dt^{'} }\text{\ and\ }Q(t) = \int_{- \infty}^{t}{I(t^{'})dt^{'} }$$

æˆ‘ä»¬å°†é€šé‡$\Phi$ä½œä¸ºå¹¿ä¹‰åæ ‡ï¼Œå…¶ä¸­$V(t')$å’Œ$I(t')$æ˜¯åœ¨æ—¶é—´$t'$æµè¿‡transmonçš„ç”µåŽ‹å’Œç”µæµã€‚åœ¨æ™®é€šçš„ç”µè·¯ä¸­ï¼Œç”µåŽ‹çš„åŠŸèƒ½éžå¸¸åƒåŠ¿èƒ½ï¼Œè€Œç”µæµåˆ™åƒåŠ¨èƒ½ã€‚åœ¨$t$æ—¶ç»è¿‡transmonçš„çž¬æ—¶èƒ½é‡ä¸ºï¼š

$$E(t) = \int_{- \infty}^{t}{V(t^{'})I(t^{'})dt^{'} }$$

ç”µå®¹$C$ä¸Žç”µæ„Ÿ$L$ä¸¤ç«¯çš„ç”µåŽ‹å’Œç”µæµåˆ†åˆ«é€šè¿‡$V = LdI/dt$å’Œ$I = CdV/dt$ç›¸äº’å…³è”ã€‚åœ¨æ™®é€šç”µè·¯ä¸­ï¼Œç”µå®¹å™¨å­˜å‚¨ç”µè·è€Œç”µæ„Ÿå™¨å­˜å‚¨é€šé‡ï¼ˆç”µæµï¼‰ã€‚æˆ‘ä»¬å°†ä½¿ç”¨é€šé‡ä½œä¸º"åæ ‡"ï¼Œç„¶å› ç”µæ„Ÿå­˜å‚¨é€šé‡ï¼Œæ‰€ä»¥åŠ¿èƒ½å¯è¡¨ç¤ºä¸ºå„ä¸ªéƒ¨åˆ†çš„ç§¯åˆ†ï¼š

$$U_{L}(t) = \int_{- \infty}^{t}{L\frac{dI(t^{'})}{dt^{'} }I(t^{'})dt^{'} } = \frac{1}{2}LI(t)^{2} = \frac{1}{2L}\Phi^{2}\text{becauseÎ¦}(t) = \int_{- \infty}^{t}{L\frac{dI(t^{'})}{dt^{'} }dt^{'} = LI(t)}$$

**çº¿æ€§ç”µè·¯çš„åˆ†æ”¯é€šé‡æ³•(Branch-Flux Method)ï¼ˆç»­ï¼‰**

ä¸Žä¸Šç›¸åŒï¼Œç”µåŽ‹æ˜¯é€šé‡çš„å˜åŒ–çŽ‡ï¼Œå…¶å¯¹åº”äºŽåŠ¨èƒ½ï¼š

$$\tau_{C}(t) = \int_{- \infty}^{t}{C\frac{\text{dV}\left( t^{'} \right)}{dt^{'} }V\left( t^{'} \right)dt^{'} } = \frac{1}{2}CV(t)^{2} = \frac{1}{2}C{\dot{\Phi} }^{2}ï¼Œ$$

$å…¶ä¸­\dot{\Phi} = \frac{d\Phi}{\text{dt} }$æ˜¯è¡¨ç¤ºæ‹‰æ ¼æœ—æ—¥åŠ›å­¦ä¸­æ—¶é—´å¯¼æ•°çš„å¸¸ç”¨æ–¹å¼ã€‚æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹å®šä¹‰ä¸ºåŠ¨èƒ½å’ŒåŠ¿èƒ½ä¹‹å·®ï¼Œå› æ­¤ï¼š

$$\mathcal{L =}\tau_{C} - U_{L} = \frac{1}{2L}\Phi^{2} - \frac{1}{2}C{\dot{\Phi} }^{2}$$

åŠ¨åŠ›å­¦æ–¹ç¨‹ç”±Euler-Lagrangeæ–¹ç¨‹ç¡®å®šï¼š

$$0 \equiv \frac{\partial\mathcal{L} }{\partial\Phi} - \frac{d}{\text{dt} }\left( \frac{\partial\mathcal{L} }{\partial\dot{\Phi} } \right) = \frac{\Phi}{L} + C\ddot{\Phi}$$

å…¶æè¿°äº†$\Phi$ä¸­è§’é¢‘çŽ‡ä¸º$\omega = 1/\sqrt{\text{LC} }$çš„è°æŒ¯å­ï¼ˆharmonic
oscillatorï¼‰ï¼Œå¼ä¸­çš„ä¸¤ä¸ªç‚¹ä¸ºäºŒé˜¶å¯¼æ•°$\ddot{\Phi} = d^{2}\Phi/dt^{2}$ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›è½¬å‘æ±‰å¯†å°”é¡¿å¸§å¹¶ä»Žä¸­è¿›è¡Œé‡åŒ–ã€‚è€Œé€šé‡$\Phi$çš„å…±è½­åæ ‡å®šä¹‰ä¸ºï¼š

$$\frac{d\mathcal{L} }{d\dot{\Phi} } = C\dot{\Phi} = CV \equiv Q$$

ç”±äºŽç”µå®¹çš„å®šä¹‰ï¼Œä»¥ä¸Šä¸Žç”µè·çš„å®šä¹‰å®Œå…¨ç›¸åŒã€‚çŽ°åœ¨ï¼Œç”¨æ‹‰æ ¼æœ—æ—¥æ³•å°†å“ˆå¯†é¡¿é‡å®šä¹‰ä¸º$\mathcal{H =}Q\dot{\Phi}\mathcal{- L}$ï¼Œå¾—å‡ºä¸Šè¿°æ–¹ç¨‹å¼ã€‚

### 3. é‡åŒ–å“ˆå¯†é¡¿é‡

é‡å­è°æŒ¯å­ï¼ˆQHOï¼šquantum harmonic
oscillatorï¼‰åœ¨é‡åŒ–$\text{LC}$ç”µè·¯å“ˆå¯†é¡¿é‡æ—¶å¾—å‡ºã€‚å°†å…±è½­å˜é‡æå‡ä¸ºç®—å­ï¼š$Q \rightarrow \widehat{Q}$ã€$\Phi \rightarrow \widehat{\Phi}$ï¼Œå› æ­¤é‡åŒ–çš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$$\widehat{H} = \frac{ {\widehat{Q} }^{2} }{2C} + \frac{ {\widehat{\Phi} }^{2} }{2L}$$

å…¶ä¸­$H$ä¸Šç­‰çš„"å¸½å­"æç¤ºæˆ‘ä»¬è¿™äº›æ˜¯é‡å­åŠ›å­¦ç®—å­ã€‚ç„¶åŽé€šè¿‡å¯¹åº”å…³ç³»å¥–åŠ±ç»å…¸åŠ›å­¦çš„æ³Šæ¾æ‹¬å·å’Œé‡å­åŠ›å­¦å¯¹æ˜“å¼ä¹‹é—´çš„å…³è”ï¼š

$$\{ A,B\} = \frac{\text{Î´A} }{\delta\Phi}\frac{\text{Î´B} }{\text{Î´Q} } - \frac{\text{Î´B} }{\delta\Phi}\frac{\text{Î´A} }{\text{Î´Q} } \Longleftrightarrow \frac{1}{\text{iâ„} }\lbrack\overset{\hat{} }{A},\overset{\hat{} }{B}\rbrack = \frac{1}{\text{iâ„} }(\overset{\hat{} }{A}\overset{\hat{} }{B} - \overset{\hat{} }{B}\overset{\hat{} }{A}),$$

å…¶ä¸­$\delta$ä¸ºå‡½æ•°å¯¼æ•°ï¼Œè€Œå¯¹æ˜“å¼åˆ™åæ˜ å‡ºæ“ä½œé¡ºåºåœ¨é‡å­åŠ›å­¦ä¸­çš„é‡è¦æ€§ã€‚æ’å…¥å˜é‡/ç®—å­ï¼Œå¾—åˆ°ï¼š

$$\{\Phi,Q\} = \frac{\delta\Phi}{\delta\Phi}\frac{\text{Î´Q} }{\text{Î´Q} } - \frac{\text{Î´Q} }{\delta\Phi}\frac{\delta\Phi}{\text{Î´Q} } = 1 - 0 = 1 \Longrightarrow \lbrack\overset{\hat{} }{\Phi},\overset{\hat{} }{Q}\rbrack = i\hslash$$

ä¸Šå¼è¡¨æ˜Žï¼šä¸Žä½ç½®å’ŒåŠ¨é‡ä¸€æ ·ï¼Œç”µè·å’Œé€šé‡ä¹Ÿéµå®ˆæµ·æ£®å ¡ä¸ç¡®å®šæ€§åŽŸç†ï¼Œä»¥åŠ$\lbrack\overset{\hat{} }{x},\overset{\hat{} }{p}\rbrack = i\hslash$ã€‚è¡¨æ˜Žå…¶ä¸å¯è¢«åŒæ—¶è§‚æµ‹ï¼Œå®žé™…ä¸Šæ˜¯ä»¥ç›¸åŒæ–¹å¼å®šä¹‰çš„å…·æœ‰ç›¸åŒå±žæ€§çš„å…±è½­å˜é‡ã€‚è¯¥ç»“æžœå·²è¢«ç”¨äºŽè¶…å¯¼é‡å­æ¯”ç‰¹ï¼Œç”¨ä»¥è®¾è®¡æ–¹æ¡ˆå¹¶åˆ†ç±»è¶…å¯¼é‡å­æ¯”ç‰¹çš„ç±»åž‹ã€‚

ä¸Šé¢çš„å“ˆå¯†é¡¿é‡é€šå¸¸ä½¿ç”¨ç®€åŒ–çš„ç”µè·$\overset{\hat{} }{n} = \overset{\hat{} }{Q}/2e$å’Œç›¸ä½$\overset{\hat{} }{\phi} = 2\pi\overset{\hat{} }{\Phi}/\Phi_{0}$ç¬¦å·ï¼Œä»¥æ›´å‹å¥½çš„å½¢å¼ç¼–å†™ï¼Œå…¶ä¸­$\Phi_{0} = h/2e$æ˜¯é€šé‡ï¼Œåˆ†åˆ«å¯¹åº”äºŽç®—å­ä¸­åº“ç€å¯¹çš„æ•°é‡å’Œè·¨çº¦ç‘Ÿå¤«æ£®ç»“çš„ç›¸ä½ã€‚ç„¶åŽï¼Œé‡åŒ–çš„å“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$${\overset{\hat{} }{H} }_{\text{QHO} } = 4E_{c}{\overset{\hat{} }{n} }^{2} + \frac{1}{2}E_{L}{\overset{\hat{} }{\phi} }^{2}$$

å…¶ä¸­$E_{c} = e^{2}/2C$ä¸ºç”µè·èƒ½é‡ï¼ˆå¼ä¸­çš„$4$å¯¹åº”äºŽæ­£åœ¨å¤„ç†çš„åº“ç€å¯¹è€Œéžå•ä¸ªç”µå­ï¼‰ï¼Œ$E_{L} = (\Phi_{0}/2\pi)^{2}/L$ä¸ºç”µæ„Ÿèƒ½é‡ã€‚

**é‡å­è°æŒ¯å­ï¼ˆQHOï¼šquantum harmonic oscillatorï¼‰**

ä¸Šé¢çš„å“ˆå¯†é¡¿é‡è¡¨ç¤ºä¸€ä¸ªç®€å•çš„æ³¢æŒ¯å­ï¼Œå¹¶ä»¥$\overset{\hat{} }{\phi}$ä½œä¸ºä½ç½®å˜é‡ï¼Œç„¶åŽæˆ‘ä»¬å¯ä»¥æ ¹æ®ç”µè·å’Œç›¸ä½çš„é›¶ç‚¹æ¶¨è½æ¥å®šä¹‰äº§ç”Ÿç®—ç¬¦å’Œæ¹®æ²¡ç®—ç¬¦ï¼š

$$\overset{\hat{} }{n} = in_{z\text{pf} }(\overset{\hat{} }{a} + {\overset{\hat{} }{a} }^{\dagger})\text{\ \ }ä¸Ž\text{\ \ }\overset{\hat{} }{\phi} = \phi_{z\text{pf} }(\overset{\hat{} }{a} - {\overset{\hat{} }{a} }^{\dagger})$$

å…¶ä¸­$n_{\text{zpf} } = {(\frac{E_{L} }{32E_{c} })}^{1/4}$ï¼Œ$\phi_{\text{zpf} } = {(\frac{2E_{c} }{E_{L} })}^{1/4}$ã€‚

è¿™å°±æ˜¯ä¸€ä¸ªè°æŒ¯å­åœ¨$\omega = \sqrt{8E_{L}E_{c} }/\hslash = 1/\sqrt{\text{LC} }$æ—¶çš„å“ˆå¯†é¡¿é‡$H_{\text{QHO} } = \hslash\omega({\overset{\hat{} }{a} }^{\dagger}\overset{\hat{} }{a} + \frac{1}{2})$ã€‚

åœ¨æ­¤å¤„ï¼Œæˆ‘ä»¬çœ‹åˆ°QHOçš„èƒ½é‡ç©ºé—´å¯¹åº”äºŽ$\text{LC}$æŒ¯å­çš„ç»å…¸è°æŒ¯é¢‘çŽ‡$\omega = 1/\sqrt{\text{LC} }$ã€‚

**Transmonçš„åˆ†æ”¯é€šé‡æ–¹æ³•**

å°½ç®¡ä¸Šè¿°å†…å®¹æ¶‰åŠé‡åŒ–çº¿æ€§ç”µè·¯ï¼Œä½†Voolä¸ŽDevoretåœ¨å…¶æ–‡ç« ã€Š[Introduction to
Quantum Electromagnetic
Circuits](https://arxiv.org/pdf/1610.03438.pdf)ã€‹ä¸­è®¨è®ºäº†é‡åŒ–ç”µè·¯çš„é€šç”¨åˆ†æ”¯é€šé‡æ–¹æ³•ã€‚è¯¥æ–‡ç« ä»Žå¤§ä½“ä¸Šç»™å‡ºäº†ä¸€ç§ç³»ç»Ÿåœ°åœ¨ç”µè·¯ä¸­å®žæ–½åŸºå°”éœå¤«å®šå¾‹çš„æ–¹æ³•ï¼šèŠ‚ç‚¹ä¸Šçš„ç”µæµæ€»å’Œå¿…ç„¶ç­‰äºŽé›¶ï¼Œå¹¶ä¸”ä»»ä½•çŽ¯è·¯å‘¨å›´çš„ç”µåŽ‹ç›¸åŠ ä¹Ÿå¿…ç„¶ç­‰äºŽé›¶ã€‚åŸºå°”éœå¤«å®šå¾‹ç»™å‡ºäº†ç”µè·¯çš„è¿åŠ¨æ–¹ç¨‹ã€‚çº¦ç‘Ÿå¤«æ£®ç»“ä¸­çš„ç”µæµä¸Žé€šé‡ä¹‹é—´å­˜åœ¨éžå¸¸ç‰¹æ®Šçš„å…³ç³»ï¼Œç”±çº¦ç‘Ÿå¤«æ£®å…³ç³»ï¼ˆJosephson
relationï¼‰ç»™å‡ºï¼š

$$I = I_{0}\sin(2\pi\Phi/\Phi_{0})$$

å…¶ä¸­$I_{0}$æ˜¯åœ¨ä¿æŒè¶…å¯¼çŠ¶æ€æ—¶å¯æµç»çº¦ç‘Ÿå¤«æ£®ç»“çš„æœ€å¤§ç”µæµï¼ˆä¸´ç•Œç”µæµï¼‰ï¼Œ$\Phi_{0} = h/2e$æ˜¯é€šé‡é‡å­ï¼ˆflux
quantumï¼‰ã€‚å®žæ–½åŸºå°”éœå¤«ç”µæµå®šå¾‹ï¼Œæµç»çº¦ç‘Ÿå¤«æ£®ç»“çš„ç”µæµä¸Žæ‰€æœ‰ç”µå®¹ä¸Šçš„ç”µæµä¹‹å’Œä¸º$C = C_{S} + C_{J}$ï¼Œå…¶ä¸­$C_{S}$æ˜¯å¹¶è”ç”µå®¹ï¼Œ$C_{J}$æ˜¯çº¦ç‘Ÿå¤«æ£®ç»“çš„ç”µå®¹ä¸”$C_{S} \gg C_{J}$ï¼Œæ•…å¿…ç„¶æ¶ˆå¤±ã€‚è¿™å°±ç»™å‡ºäº†è¿åŠ¨æ–¹ç¨‹ï¼š

$$I_{0}\sin\left( \frac{2\pi\Phi}{\Phi_{0} } \right) + C\ddot{\Phi} = 0$$

ä¸Žåœ¨QHOæƒ…å†µä¸‹é€šè¿‡å°†æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹æ”¾å…¥Euler-Lagrangeæ–¹ç¨‹æ¥è®¡ç®—è¿åŠ¨æ–¹ç¨‹çš„å…¸åž‹æƒ…å†µä¸åŒï¼Œæ­¤å¤„æˆ‘ä»¬å·²ç»æœ‰äº†å˜é‡$\Phi$çš„è¿åŠ¨æ–¹ç¨‹ã€‚ä½†ç”±äºŽæˆ‘ä»¬è¦å¯¹å“ˆå¯†é¡¿é‡è¿›è¡Œé‡åŒ–ï¼Œå› æ­¤å°†è¯¥è¿åŠ¨æ–¹ç¨‹å¼è½¬æ¢ä¸ºæ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹ï¼Œç„¶åŽæ‰§è¡Œå‹’è®©å¾·å˜æ¢æ¥æ‰¾å‡ºå“ˆå¯†é¡¿é‡ï¼Œå¯ä»¥é€šè¿‡å¯¹è¿åŠ¨æ–¹ç¨‹è¿›è¡Œ"ç§¯åˆ†"æ¥å®žçŽ°ï¼š

$$0 = \frac{\partial\mathcal{L} }{\partial\Phi} - \frac{d}{\text{dt} }(\frac{\partial\mathcal{L} }{\partial\dot{\Phi} }) = I_{0}\sin(2\pi\Phi/\Phi_{0}) + C\ddot{\Phi} \Longrightarrow \frac{I_{0}\Phi_{0} }{2\pi}\cos(2\pi\Phi/\Phi_{0}) + \frac{C{\dot{\Phi} }^{2} }{2}\mathcal{= L}$$

æˆ‘ä»¬é€šè¿‡å›žæº¯æ‰¾å‡ºäº†æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹ã€‚çŽ°åœ¨ï¼Œé€šè¿‡æ‰¾åˆ°å…±è½­å˜é‡$Q = \partial\mathcal{L/}\partial\dot{\Phi} = C\dot{\Phi}$æ¥æ‰¾åˆ°å“ˆå¯†é¡¿é‡ï¼Œä¸ŽQHOçš„æƒ…å†µç›¸åŒã€‚

$$\mathcal{H =}Q\dot{\Phi}\mathcal{- L =}\frac{Q^{2} }{2C} - \frac{I_{0}\Phi_{0} }{2\pi}\cos(2\pi\Phi/\Phi_{0})$$

### 4. é‡åŒ–Transmon

è¿›è¡Œä¸ŽQHOç›¸åŒçš„å˜é‡æ›¿ä»£ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ç†Ÿæ‚‰çš„å½¢å¼é‡å†™transmonçš„å“ˆå¯†é¡¿é‡ã€‚

$${\overset{\hat{} }{H} }_{\text{tr} } = 4E_{c}{\overset{\hat{} }{n} }^{2} - E_{J}\cos\overset{\hat{} }{\phi}$$

å…¶ä¸­çº¦ç‘Ÿå¤«æ£®èƒ½é‡$E_{J} = I_{0}\Phi_{0}/2\pi$æ›¿ä»£äº†QHOçš„ç”µæ„Ÿèƒ½é‡ã€‚å¯ä»¥çœ‹å‡ºï¼šç”±äºŽçº¦ç‘Ÿå¤«æ£®ç»“ä»£æ›¿äº†çº¿æ€§ç”µæ„Ÿï¼Œå› æ­¤è¯¥ç›¸çš„å‡½æ•°å½¢å¼ä¸ŽQHOæœ‰æ‰€ä¸åŒã€‚é€šå¸¸$\overset{\hat{} }{n} \rightarrow \overset{\hat{} }{n} - n_{g}$åæ˜ æ …æžåç½®ç”µè·ï¼Œä½†åœ¨transmonä¸­å¹¶ä¸é‡è¦ã€‚è‡³æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼äºŽQHOçš„é‡åŒ–æ–¹æ³•ï¼Œå…¶ä¸­ä¸€å¥ç”µè·å’Œç›¸ä½çš„é›¶ç‚¹æ³¢åŠ¨æ¥å®šä¹‰äº§ç”Ÿç®—ç¬¦å’Œæ¹®æ²¡ç®—ç¬¦ï¼š

$$\overset{\hat{} }{n} = in_{z\text{pf} }(\overset{\hat{} }{c} + {\overset{\hat{} }{c} }^{\dagger})\text{\ \ }ä¸Ž\text{\ \ }\overset{\hat{} }{\phi} = \phi_{z\text{pf} }(\overset{\hat{} }{c} - {\overset{\hat{} }{c} }^{\dagger})$$

å…¶ä¸­$n_{\text{zpf} } = {(\frac{E_{J} }{32E_{c} })}^{1/4}$ï¼Œ$\phi_{\text{zpf} } = {(\frac{2E_{c} }{E_{J} })}^{1/4}$ï¼Œçº¦ç‘Ÿå¤«æ£®èƒ½é‡$E_{J}$å–ä»£äº†QHOçš„çº¿æ€§ç”µæ„Ÿèƒ½é‡$E_{L}$ã€‚æ­¤å¤„æˆ‘ä»¬ä½¿ç”¨äº†$\overset{\hat{} }{c} = \sum_{j}^{}{\sqrt{j + 1}|j\rangle\langle j + 1|}$è¡¨ç¤ºtransmonæ¹®æ²¡ç®—ç¬¦ï¼Œå¹¶å°†å…¶ä¸Žç­‰é—´éš”èƒ½é‡æ¨¡å¼$\widehat{a}$åŒºåˆ†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°$\phi \ll 1$çš„åŽŸå› æ˜¯åœ¨transmonä¸­$E_{J}/E_{c} \gg 1$ï¼Œæˆ‘ä»¬å¯ä»¥å°†$\cos\widehat{\phi}$çš„æ³°å‹’å±•å¼€å¼è¿‘ä¼¼ä¸ºå“ˆå¯†é¡¿é‡ï¼š

$$H = 4E_{c}n_{\text{zpf} }^{2}(\overset{\hat{} }{c} + {\overset{\hat{} }{c} }^{\dagger})^{2} - E_{J}(1 - \frac{1}{2}E_{J}\phi_{\text{zpf} }^{2}(\overset{\hat{} }{c} - {\overset{\hat{} }{c} }^{\dagger})^{2} + \frac{1}{24}E_{J}\phi_{\text{zpf} }^{4}(\overset{\hat{} }{c} - {\overset{\hat{} }{c} }^{\dagger})^{4} + \ldots) \approx \sqrt{8E_{c}E_{J} }({\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c} + \frac{1}{2}) - E_{J} - \frac{E_{c} }{12}({\overset{\hat{} }{c} }^{\dagger} + \overset{\hat{} }{c})^{4}$$

å…¶ä¸­æˆ‘ä»¬è§‚å¯Ÿåˆ°$4E_{c}n_{\text{zpf} }^{2} = (1/2)E_{J}\phi_{\text{zpf} }^{2} = \sqrt{2E_{c}E_{J} }$éžå¸¸æœ‰ç”¨ã€‚æ‰©å±•transmonè¿ç®—ç¬¦$\widehat{c}$çš„é¡¹å¹¶åˆ é™¤å¿«é€Ÿæ—‹è½¬é¡¹ï¼ˆå³ï¼šæ•°é‡ä¸ç­‰çš„$\widehat{c}$ä¸Ž${\widehat{c} }^{\dagger}$ï¼‰ï¼Œå¿½ç•¥ä¸å½±å“transmonåŠ¨æ€çš„å¸¸æ•°ï¼Œè®¾å®š$\omega_{0} = \sqrt{8E_{c}E_{J} }$å¹¶å°†$\delta = - E_{c}$å®šä¹‰ä¸ºtransmonéžè°æ€§ï¼Œå¾—å‡ºï¼š

$${\overset{\hat{} }{H} }_{\text{tr} } = \omega_{0}{\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c} + \frac{\delta}{2}(({\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c})^{2} + {\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c}) = (\omega_{0} + \frac{\delta}{2}){\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c} + \frac{\delta}{2}({\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c})^{2}$$

ä¸Šå¼å°±æ˜¯æœèŠ¬æŒ¯å­ï¼ˆDuffing
oscillatorï¼‰çš„å“ˆå¯†é¡¿é‡ã€‚é€šè¿‡å®šä¹‰$\omega \equiv \omega_{0} + \delta$ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å› $\omega_{j + 1} - \omega_{j} = \omega + \delta j$
transmonèƒ½çº§é—´æ‰€å­˜åœ¨çš„èƒ½é‡é—´éš”å› éžè°æ€§è€Œä¸åŒï¼Œå› æ­¤$\omega$å¯¹åº”äºŽtransmoné‡å­æ¯”ç‰¹çš„"é¢‘çŽ‡"ï¼ˆ$\omega_{1} - \omega_{0}$ï¼‰ã€‚ä»Žtransmonè¿ç®—ç¬¦çš„å®šä¹‰${\widehat{c} }^{\dagger}\widehat{c} = \sum_{j}^{}{j|j\rangle\langle j|}$å¾—å‡ºï¼š

$${\overset{\hat{} }{H} }_{\text{tr} } = \omega{\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c} + \frac{\delta}{2}{\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c}({\overset{\hat{} }{c} }^{\dagger}\overset{\hat{} }{c} - 1) = \sum_{j}^{}{((\omega - \frac{\delta}{2})j + \frac{\delta}{2}j^{2})|j\rangle\langle j|} \equiv \sum_{j}^{}{\omega_{j}|j\rangle\langle j|}$$

å› æ­¤ï¼Œ

$$\omega_{j} = (\omega - \frac{\delta}{2})j + \frac{\delta}{2}j^{2}$$

å°±æ˜¯transmonçš„èƒ½çº§ã€‚

### 5. Transmonä¸Žé‡å­è°æŒ¯å­çš„æ¯”è¾ƒ

QHOå…·æœ‰ç­‰é—´éš”èƒ½çº§è€Œtransmonæ²¡æœ‰ï¼Œè¿™å°±æˆ‘ä»¬å¯ä»¥å°†transmonå½“ä½œé‡å­æ¯”ç‰¹çš„åŽŸå› ã€‚æ­¤å¤„ï¼Œæˆ‘ä»¬é€šè¿‡ä½¿ç”¨[QuTiP](http://www.qutip.org/)ï¼ˆä½¿ç”¨pipå®‰è£…ï¼‰ä¾æ®å…¶å“ˆå¯†é¡¿é‡è®¡ç®—å‡ºèƒ½çº§çš„å·®å¼‚ã€‚

> import numpy as np
>
> import matplotlib.pyplot as plt
>
> E_J = 20e9
>
> w = 5e9
>
> anharm = -300e6
>
> N_phis = 101
>
> phis = np.linspace(-np.pi,np.pi,N_phis)
>
> mid_idx = int((N_phis+1)/2)
>
> \# potential energies of the QHO & transmon
>
> U_QHO = 0.5\*E_J\*phis\*\*2
>
> U_QHO = U_QHO/w
>
> U_transmon = (E_J-E_J\*np.cos(phis))
>
> U_transmon = U_transmon/w
>
> \# import QuTiP, construct Hamiltonians, and solve for energies
>
> from qutip import destroy
>
> N = 35
>
> N_energies = 5
>
> c = destroy(N)
>
> H_QHO = w\*c.dag()\*c
>
> E_QHO = H_QHO.eigenenergies()\[0:N_energies\]
>
> H_transmon = w\*c.dag()\*c + (anharm/2)\*(c.dag()\*c)\*(c.dag()\*c -
> 1)
>
> E_transmon = H_transmon.eigenenergies()\[0:2\*N_energies\]
>
> print(E_QHO\[:4\])
>
> print(E_transmon\[:8\])
>
> è¾“å‡ºï¼š
>
> \[0.0e+00 5.0e+09 1.0e+10 1.5e+10\]
>
> \[0.00e+00 1.70e+09 5.00e+09 6.60e+09 9.70e+09 1.12e+10 1.41e+10
> 1.55e+10\]
>
> fig, axes = plt.subplots(1, 1, figsize=(6,6))
>
> axes.plot(phis, U_transmon, \'-\', color=\'orange\', linewidth=3.0)
>
> axes.plot(phis, U_QHO, \'\--\', color=\'blue\', linewidth=3.0)
>
> for eidx in range(1,N_energies):
>
> delta_E\_QHO = (E_QHO\[eidx\]-E_QHO\[0\])/w
>
> delta_E\_transmon = (E_transmon\[2\*eidx\]-E_transmon\[0\])/w
>
> QHO_lim_idx = min(np.where(U_QHO\[int((N_phis+1)/2):N_phis\] \>
> delta_E\_QHO)\[0\])
>
> trans_lim_idx = min(np.where(U_transmon\[int((N_phis+1)/2):N_phis\] \>
> delta_E\_transmon)\[0\])
>
> trans_label, = axes.plot(\[phis\[mid_idx-trans_lim_idx-1\],
> phis\[mid_idx+trans_lim_idx-1\]\], \\
>
> \[delta_E\_transmon, delta_E\_transmon\], \'-\', color=\'orange\',
> linewidth=3.0)
>
> qho_label, = axes.plot(\[phis\[mid_idx-QHO_lim_idx-1\],
> phis\[mid_idx+QHO_lim_idx-1\]\], \\
>
> \[delta_E\_QHO, delta_E\_QHO\], \'\--\', color=\'blue\',
> linewidth=3.0)
>
> axes.set_xlabel(\'Phase \$\\phi\$\', fontsize=24)
>
> axes.set_ylabel(\'Energy Levels / \$\\hbar\\omega\$\', fontsize=24)
>
> axes.set_ylim(-0.2,5)
>
> qho_label.set_label(\'QHO Energies\')
>
> trans_label.set_label(\'Transmon Energies\')
>
> axes.legend(loc=2, fontsize=14)

![](pics/media/image364.png)

### 6. é‡å­æ¯”ç‰¹é©±åŠ¨ä¸Žæ—‹è½¬æ³¢è¿‘ä¼¼ï¼ˆRotating Wave Approximationï¼ŒRWAï¼‰

æ–½åŠ ä¸€ä¸ªç”µé©±åŠ¨åœº$\overset{\rightarrow}{E}(t) = {\overset{\rightarrow}{E} }_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{E} }_{0}^{*}e^{i\omega_{d}t}$è‡³transmonï¼Œåœ¨transmonå’Œå¾®æ³¢åœºä¹‹é—´å¼•å…¥äº†ä¸€ä¸ªå¶æžå­ç›¸äº’ä½œç”¨ï¼ˆdipole
interactionï¼‰ã€‚æˆ‘ä»¬åœ¨æ­¤å¤„å°†transmonç›´æŽ¥æ˜¯ä¸ºä¸€ä¸ªé‡å­æ¯”ç‰¹ï¼Œå› æ­¤transmonçš„å“ˆå¯†é¡¿é‡æ˜¯é‡å­æ¯”ç‰¹å“ˆå¯†é¡¿é‡${\widehat{H} }_{0}$ä¸Žé©±åŠ¨å“ˆå¯†é¡¿é‡${\widehat{H} }_{d}$çš„å’Œï¼š

$$\overset{\hat{} }{H} = {\overset{\hat{} }{H} }_{0} + {\overset{\hat{} }{H} }_{d}\text{\ \ }ä»¥åŠ\text{\ \ }{\overset{\hat{} }{H} }_{0} = - \frac{1}{2}\hslash\omega_{q}\sigma^{z}$$

å…¶ä¸­$\sigma^{z}$æ˜¯Pauli$- Z$çŸ©é˜µã€‚æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨Pauliä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦$\sigma^{\pm} = (1/2)(\sigma^{x} \mp i\sigma^{y})$ï¼Œè¿™ä¸¤ä¸ªç®—ç¬¦æœ‰ä½¿å¾—$\sigma^{+}|0\rangle = |1\rangle$ä»¥åŠ$\sigma^{+}|1\rangle = |0\rangle$çš„æ•ˆæžœã€‚æ­¤å¤„åº”å½“æ³¨æ„ï¼Œè¯¥å®šä¹‰åæ˜ å‡ºæˆ‘ä»¬æ‰€ä½¿ç”¨çš„æ˜¯é‡å­æ¯”ç‰¹ä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦ï¼Œè€Œéžæ—‹è½¬è¿ç®—ç¬¦ã€‚å› åœ¨ç¬¬1èŠ‚ä¸­å·²è®¨è®ºçš„åŽŸå› ï¼Œ$|0\rangle \equiv | \uparrow \rangle$å’Œ$|1\rangle \equiv | \downarrow \rangle$ä½¿å¾—ä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦åè½¬ã€‚çŽ°å› åœºèƒ½æ¿€å‘å’Œåˆ¶æ¿€é‡å­æ¯”ç‰¹ï¼Œå®šä¹‰å¶æžç®—ç¬¦$\overset{\rightarrow}{d} = {\overset{\rightarrow}{d} }_{0}\sigma^{+} + {\overset{\rightarrow}{d} }_{0}^{*}\sigma^{-}$ã€‚å¶æžå­ç›¸äº’ä½œç”¨çš„é©±åŠ¨å“ˆå¯†é¡¿é‡ä¸ºï¼š

$${\overset{\hat{} }{H} }_{d} = - \overset{\rightarrow}{d} \cdot \overset{\rightarrow}{E}(t) = - ({\overset{\rightarrow}{d} }_{0}\sigma^{+} + {\overset{\rightarrow}{d} }_{0}^{*}\sigma^{-}) \cdot ({\overset{\rightarrow}{E} }_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{E} }_{0}^{*}e^{i\omega_{d}t}) = - ({\overset{\rightarrow}{d} }_{0} \cdot {\overset{\rightarrow}{E} }_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{d} }_{0} \cdot {\overset{\rightarrow}{E} }_{0}^{*}e^{i\omega_{d}t})\sigma^{+} - ({\overset{\rightarrow}{d} }_{0}^{*} \cdot {\overset{\rightarrow}{E} }_{0}e^{- i\omega_{d}t} + {\overset{\rightarrow}{d} }_{0}^{*} \cdot {\overset{\rightarrow}{E} }_{0}^{*}e^{i\omega_{d}t})\sigma^{-} \equiv - \hslash(\Omega e^{- i\omega_{d}t} + \overset{\sim}{\Omega}e^{i\omega_{d}t})\sigma^{+} - \hslash({\overset{\sim}{\Omega} }^{*}e^{- i\omega_{d}t} + \Omega^{*}e^{i\omega_{d}t})\sigma^{-}$$

ä¸ºæè¿°åœºå’Œå¶æžå­çš„å¼ºåº¦ï¼Œä¸Šå¼ä¸­è¿›è¡Œäº†$\Omega = {\overset{\rightarrow}{d} }_{0} \cdot {\overset{\rightarrow}{E} }_{0}$ä¸Ž$\overset{\sim}{\Omega} = {\overset{\rightarrow}{d} }_{0} \cdot {\overset{\rightarrow}{E} }_{0}^{*}$çš„æ›¿æ¢ã€‚çŽ°åœ¨ï¼Œä½¿ç”¨ä¸‹å¼å˜æ¢ç›¸äº’ç»˜æ™¯ï¼ˆç‹„æ‹‰å…‹ç»˜æ™¯Dirac
pictureï¼‰${\overset{\hat{} }{H} }_{d,I} = U{\overset{\hat{} }{H} }_{d}U^{\dagger}$ï¼ˆå…¶ä¸­çœç•¥çš„é€€å‡ºé¡¹ï¼‰ï¼š

$$U = e^{i{\overset{\hat{} }{H} }_{0}t/\hslash} = e^{- i\omega_{q}t\sigma^{z}/2} = I\cos(\omega_{q}t/2) - i\sigma^{z}\sin(\omega_{q}t/2)$$

è®¡ç®—ç®—ç¬¦é¡¹ï¼š

$$\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) - i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right)\sigma^{+}\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) + i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right) = e^{i\omega_{q}t}\sigma^{+}$$

$$\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) - i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right)\sigma^{-}\left( \text{Icos}\left( \frac{\omega_{q}t}{2} \right) + i\sigma^{z}\sin\left( \frac{\omega_{q}t}{2} \right) \right) = e^{- i\omega_{q}t}\sigma^{-}$$

å˜æ¢åŽçš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$${\overset{\hat{} }{H} }_{d,I} = U{\overset{\hat{} }{H} }_{d}U^{\dagger} = - \hslash(\Omega e^{- i\omega_{d}t} + \overset{\sim}{\Omega}e^{i\omega_{d}t})e^{i\omega_{q}t}\sigma^{+} - \hslash({\overset{\sim}{\Omega} }^{*}e^{- i\omega_{d}t} + \Omega^{*}e^{i\omega_{d}t})e^{- i\omega_{q}t}\sigma^{-} = - \hslash(\Omega e^{- i\Delta_{q}t} + \overset{\sim}{\Omega}e^{i(\omega_{q} + \omega_{d})t})\sigma^{+} - \hslash({\overset{\sim}{\Omega} }^{*}e^{- i(\omega_{q} + \omega_{d})t} + \Omega^{*}e^{i\Delta_{q}t})\sigma^{-}$$

çŽ°åœ¨è¿›è¡Œæ—‹è½¬æ³¢è¿‘ä¼¼ï¼šç”±äºŽ$\omega_{q} + \omega_{d}$è¿œå¤§äºŽ$\Delta_{q} = \omega_{q} - \omega_{d}$ï¼Œå¸¦æœ‰æŒ‡æ•°å’Œçš„é¡¹å¿«é€ŸæŒ¯è¡ï¼Œæœ‰æ•ˆåœ°å¹³è¡¡äº†å…¶è´¡çŒ®ï¼Œå› æ­¤æˆ‘ä»¬ä»Žå¯ä»¥ä»Žå“ˆå¯†é¡¿é‡ä¸­åˆ é™¤è¿™äº›é¡¹ã€‚è‡³æ­¤RWAäº¤äº’å“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$${\overset{\hat{} }{H} }_{d,I}^{(\text{RWA})} = - \hslash\Omega e^{- i\Delta_{q}t}\sigma^{+} - \hslash\Omega^{*}e^{i\Delta_{q}t}\sigma^{-}$$

å›žåˆ°è–›å®šè°”ç»˜æ™¯ï¼ˆSchrÃ¶dinger pictureï¼‰ï¼š

$${\overset{\hat{} }{H} }_{d}^{(\text{RWA})} = U^{\dagger}{\overset{\hat{} }{H} }_{d,I}^{(\text{RWA})}U = - \hslash\Omega e^{- i\omega_{d}t}\sigma^{+} - \hslash\Omega^{*}e^{i\omega_{d}t}\sigma^{-}$$

å› æ­¤æ‰€æœ‰é‡å­æ¯”ç‰¹å’Œé©±åŠ¨çš„å“ˆå¯†é¡¿é‡ä¸ºï¼š

$${\overset{\hat{} }{H} }^{(\text{RWA})} = - \frac{1}{2}\hslash\omega_{q}\sigma^{z} - \hslash\Omega e^{- i\omega_{d}t}\sigma^{+} - \hslash\Omega^{*}e^{i\omega_{d}t}\sigma^{-}.$$

è¿›å…¥é©±åŠ¨å¸§ï¼Œä½¿ç”¨$U_{d} = \exp\{ - i\omega_{d}t\sigma^{z}/2\}$å˜æ¢ï¼Œå“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$${\overset{\hat{} }{H} }_{\text{eff} } = U_{d}{\overset{\hat{} }{H} }^{(\text{RWA})}U_{d}^{\dagger} - i\hslash U_{d}{\overset{Ë™}{U} }_{d}^{\dagger}$$

å…¶ä¸­${\overset{Ë™}{U} }_{d} = dU_{d}/dt$æ˜¯$U_{d}$çš„æ—¶é—´å¯¼æ•°ã€‚åœ¨RWAä¸‹çš„é©±åŠ¨å™¨å¸§ä¸­ï¼š

$${\overset{\hat{} }{H} }_{\text{eff} } = - \frac{1}{2}\hslash\omega_{q}\sigma^{z} - \hslash\Omega\sigma^{+} - \hslash\Omega^{*}\sigma^{-} + \frac{1}{2}\hslash\omega_{d}\sigma^{z} = - \frac{1}{2}\hslash\Delta_{q}\sigma^{z} - \hslash\Omega\sigma^{+} - \hslash\Omega^{*}\sigma^{-}$$

å‡è®¾é©±åŠ¨çœŸå®žï¼Œå› æ­¤$\Omega = \Omega^{*}$ï¼Œåˆ™ä¸Šå¼å¯ç®€åŒ–ä¸ºï¼š

$${\overset{\hat{} }{H} }_{\text{eff} } = - \frac{1}{2}\hslash\Delta_{q}\sigma^{z} - \hslash\Omega\sigma^{x}.$$

è¡¨æ˜Žï¼šå½“é©±åŠ¨ä¸Žé‡å­æ¯”ç‰¹è°æŒ¯æ—¶ï¼ˆå³$\Delta_{q} = 0$ï¼‰ï¼Œé©±åŠ¨ä¼šåœ¨Blochçƒä¸­å¼•èµ·$x$æ—‹è½¬ï¼Œè¯¥æ—‹è½¬ç”±$\sigma^{x}$äº§ç”Ÿï¼Œå…¶å¼ºåº¦ä¸º$\Omega$ã€‚æˆ‘ä¹ˆå¯ä»¥åœ¨"é€šè¿‡Qiskitè„‰å†²æ ¡å‡†é‡å­æ¯”ç‰¹"ä¸€èŠ‚çœ‹åˆ°è¿™ä¸€è°æŒ¯é‡å­æ¯”ç‰¹ä¸Žé©±åŠ¨çš„æ•ˆæžœã€‚å¤±è°é©±åŠ¨å…·æœ‰è‡ª$\sigma^{z}$äº§ç”Ÿçš„å…¶ä»–$z$æ—‹è½¬ï¼Œè¿™äº›æ—‹è½¬åœ¨Ramseyå®žéªŒä¸­è¡¨çŽ°ä¸ºæŒ¯è¡ã€‚

6.4 é‡å­å›žè·¯çš„é‡å­ç”µåŠ¨åŠ›å­¦
--------------------------

### å†…å®¹

1\. ç®€ä»‹

2\. Schrieffer-Wolffå˜æ¢

3\. Jaynes-Cummingså“ˆå¯†é¡¿é‡çš„å—å¯¹è§’åŒ–

4\. å…¨Transmon

5\. å…·æœ‰cQEDçš„Qubité©±åŠ¨

6\. äº¤å‰è°æŒ¯çº ç¼ é‡å­é—¨

### 1. ç®€ä»‹

é€šè¿‡ç±»æ¯”è…”é‡å­ç”µåŠ¨åŠ›å­¦ï¼ˆCavity Quantum
Electrodynamicsï¼ŒCQEDï¼‰ï¼Œå›žè·¯ç”µåŠ¨åŠ›å­¦ï¼ˆcircuit
QEDï¼ŒcQEDï¼‰è¿ç”¨äº†ä½¿ç”¨ç®€å•æ¨¡åž‹æ¥æè¿°åŽŸå­ä¸Žå…‰å­¦è…”ä»¥åŠé‡å­æ¯”ç‰¹ä¸Žå¾®æ³¢è°æŒ¯å™¨ç›¸äº’ä½œç”¨çš„åŽŸç†ã€‚è¯¥æ¨¡åž‹åŒ…æ‹¬ç©ºè…”/è°æŒ¯å™¨ä¸­çš„å…‰å­æ•°é‡

ã€åŽŸå­/é‡å­æ¯”ç‰¹çš„çŠ¶æ€ä»¥åŠåŽŸå­/é‡å­æ¯”ç‰¹ä¸Žç©ºè…”/è°æŒ¯å™¨ä¹‹é—´çš„ç”µå¶æžå­ç›¸äº’ä½œç”¨ã€‚æ­£å¦‚åœ¨ä¸Šä¸€èŠ‚ä¸­æ‰€è¿°ï¼Œtransmonå®žé™…ä¸Šæ˜¯å¤šèƒ½çº§ç³»ç»Ÿï¼Œä½†æ˜¯ç”±äºŽtransmonçš„éžè°æ€§ï¼Œå¯èƒ½å°†å…¶è‡ªèº«é™åˆ¶åœ¨åŸºæ€$|0\rangle = |g\rangle$å’Œç¬¬ä¸€æ¿€å‘æ€çš„$|1\rangle = |e\rangle$ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†transmonæè¿°ä¸ºPauliè‡ªæ—‹çŸ©é˜µ$\sigma^{x} = (\begin{matrix}
0 & 1 \\
1 & 0 \\
\end{matrix})\text{\ \ Ïƒ}^{y} = (\begin{matrix}
0 & - i \\
i & 0 \\
\end{matrix})\text{\ \ Ïƒ}^{z} = (\begin{matrix}
1 & 0 \\
0 & - 1 \\
\end{matrix})$æ‰€æè¿°çš„ä¸€ä¸ªé‡å­æ¯”ç‰¹ä¾æ®å›´ç»•Blochçƒå„ä¸ªè½´çš„æ—‹è½¬ã€‚åœ¨è¿™ä¸€æƒ…å†µä¸‹ï¼Œæè¿°è¿™ç§äº¤äº’ä½œç”¨æœ€ç®€å•çš„æ¨¡åž‹æ˜¯æ—‹è½¬æ³¢é€¼è¿‘ä¸­çš„Jaynes-Cummingså“ˆå¯†é¡¿é‡ï¼š

$$H_{\text{JC} }^{(\text{RWA})}/\hslash = \omega_{r}a^{\dagger}a + \frac{1}{2}\omega_{q}\sigma_{z} + g(a^{\dagger}\sigma^{-} + a\sigma^{+}).$$

å…¶ä¸­$\omega_{r}$å’Œ$\omega_{q}$åˆ†åˆ«ä¸ºè°æŒ¯å™¨ï¼ˆresonatorï¼‰å’Œ"é‡å­æ¯”ç‰¹ï¼ˆqubitï¼‰"çš„é¢‘çŽ‡ï¼Œ$a(a^{\dagger})$æ˜¯è°æŒ¯å™¨å…‰å­æ¹®ç­ï¼ˆäº§ç”Ÿï¼‰ç®—ç¬¦ï¼Œ$g$æ˜¯ç”µå¶æžè€¦åˆï¼ˆåŠçœŸç©ºRabiåˆ†è£‚ï¼‰ã€‚è¯·æ³¨æ„æ­¤å¤„çœç•¥äº†ç®—ç¬¦çš„å¸½å­"hat"ã€‚ç¬¬ä¸€é¡¹å¯¹åº”äºŽè°æŒ¯å™¨ä¸­çš„å…‰å­æ•°ï¼Œç¬¬äºŒé¡¹å¯¹åº”äºŽé‡å­æ¯”ç‰¹çš„çŠ¶æ€ï¼Œç¬¬ä¸‰é¡¹æ˜¯ç”µå¶æžå­ç›¸äº’ä½œç”¨ï¼Œå…¶ä¸­$\sigma^{\pm} = (1/2)(\sigma^{x} \mp i\sigma^{y})$ä¸ºé‡å­æ¯”ç‰¹ä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦ã€‚ï¼ˆå¦‚ä¸Šä¸€ç« æ‰€è¿°ï¼Œæ‰€ä½¿ç”¨çš„ç¬¦å·ä¸Žæ—‹è½¬ä¸Šä¸Šå‡ç®—ç¬¦/ä¸‹é™ç®—ç¬¦çš„ç¬¦å·ç›¸åã€‚ï¼‰

è¿™ä¸€å“ˆå¯†é¡¿é‡å¯ä»¥ç²¾ç¡®æ±‚è§£ï¼Œè§£ä¸ºé‡å­æ¯”ç‰¹/è°æŒ¯å™¨çš„æ··åˆçŠ¶æ€ï¼Œå½“å¤„äºŽå…±æŒ¯çŠ¶æ€ï¼ˆ$\omega_{r} = \omega_{q}$ï¼‰æ—¶ä¸¤è€…ä¹‹é—´çš„æ¿€å‘ï¼ˆæ— è®ºå…±æŒ¯å™¨ä¸­çš„å…‰å­è¿˜æ˜¯é‡å­æ¯”ç‰¹çš„æ¿€å‘æ€ï¼‰äº¤æ¢é€ŸçŽ‡ä¸º$g$ã€‚ä¾‹å¦‚ï¼Œåœ¨é¡¹$a^{\dagger}\sigma^{-}$æ¶ˆç­äº†å…±æŒ¯å™¨ä¸­çš„ä¸€ä¸ªå…‰å­æˆ–å°†é‡å­æ¯”ç‰¹ä»Žæ€$|0\rangle$æ¿€å‘è‡³æ€$|1\rangle$æ—¶ï¼Œç¬¬ä¸‰é¡¹ä¸­çš„$a^{\dagger}\sigma^{-}$åœ¨å…±æŒ¯å™¨ä¸­åˆ›å»ºäº†ä¸€ä¸ªå…‰å­å¹¶å°†é‡å­æ¯”ç‰¹ä»Žæ€$|1\rangle$æ‹‰ä½Žä¸ºæ€$|0\rangle$ã€‚å…¶ä¸­æœ‰è¶£çš„æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨é‡å­è®¡ç®—æœºå¤„ç†é‡å­æ¯”ç‰¹ä¿„æ—¥éžæ··åˆçŠ¶æ€ã€‚è¡¨æ˜Žéœ€è¦å°†è°æŒ¯å™¨å½“ä½œå¯¹äºŽé‡å­æ¯”ç‰¹çš„æ‘„åŠ¨ï¼ˆåä¹‹äº¦ç„¶ï¼‰ï¼Œå› æ­¤å…¶æ€§è´¨ä»…ä»…å› ä¸ºå¯¹æ–¹çš„å­˜åœ¨è€Œå­˜åœ¨ã€‚ä½¿ç”¨ä¸€ç§ç§°ä¸ºSchrieffer-Wolffï¼ˆS-Wï¼‰å˜æ¢çš„æ‘„åŠ¨ç†è®ºï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æƒ³è¦çš„æ“ä½œçŠ¶æ€ä¸‹è®¡ç®—é‡å­æ¯”ç‰¹å’Œè°æŒ¯å™¨çš„ç‰¹æ€§ã€‚æ­¤å¤„åº”æ³¨æ„ï¼Œå‡ºäºŽæ•™å­¦ä¸Šçš„åŽŸå› å°†transmonè§†ä¸ºqubitæ˜¯ä»…é€‚ç”¨äºŽè§£è¯´ï¼Œä½†å½“è€ƒè™‘transmonçš„æ‰€æœ‰èƒ½çº§æ—¶å¯ä»¥åº”ç”¨ç›¸åŒçš„æŠ€æœ¯ã€‚Transmonçš„è¾ƒé«˜èƒ½çº§çš„ä½œç”¨æ›´åŠ å¹¿æ³›ï¼Œåœ¨å¯¹å…¶è¿›è¡Œè®¾è®¡å’Œæ¨¡æ‹Ÿæ—¶å¿…é¡»åŠ ä»¥è€ƒè™‘ã€‚

### 2. Schrieffer-Wolffå˜æ¢

**è–›å®šè°”æ–¹ç¨‹**

é‡å­åŠ›å­¦ä¸­çš„é—®é¢˜é€šå¸¸æ˜¯å°†å“ˆå¯†é¡¿ç‰¹å¾å€¼æ–¹ç¨‹å¯¹è§’åŒ–çš„é—®é¢˜ï¼š

$$H\psi_{m} = E_{m}\psi_{m}\text{\ \ \ \ \ \ for\ \ \ \ \ \ }1 \leq m \leq n$$

å…¶ä¸­$\psi_{m}$æ˜¯æœ¬å¾å€¼$E_{m}$çš„æœ¬å¾æ€ã€‚å…¶ä¸­åŒ…å«æ‰¾å‡ºä¸€ä¸ªç±»ä¼¼å¯¹è§’çŸ©é˜µ$H^{'} = UHU^{\dagger}$çš„å¹ºæ­£çŸ©é˜µ$U$ã€‚åˆ™æœ¬å¾å€¼çš„æ–¹ç¨‹å˜ä¸ºï¼š

$$\overset{\hat{} }{H}\psi_{m} = E_{m}\psi_{m} \Longrightarrow UHU^{\dagger}U\psi_{m} = E_{m}U\psi_{m} \Longrightarrow H^{'}\psi_{m}^{'} = E_{m}\psi_{m}^{'}$$

å…¶ä¸­$\psi_{m}^{'} = U\psi_{m}$æ˜¯å˜æ¢åŽçš„æœ¬å¾æ€ï¼Œä»¥åŠ

$$H^{'} = \begin{pmatrix}
E_{1} & 0 & \cdots & 0 \\
0 & E_{2} & \cdots & 0 \\
 \vdots & \vdots & \ddots & 0 \\
0 & 0 & \cdots & E_{n} \\
\end{pmatrix}$$

æ˜¯å¯¹è§’å“ˆå¯†é¡¿é‡ã€‚

é€šè¿‡ç”¨S-Wå˜æ¢ä»£æ›¿å“ˆå¯†é¡¿é‡çš„å¯¹è§’åŒ–ï¼Œæˆ‘ä»¬å¯»æ±‚å°†å…¶å—å¯¹è§’åŒ–ï¼ˆ*block-diagonalize*ï¼‰ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå“ˆå¯†é¡¿é‡ï¼Œå¯ä»¥å°†å…¶åˆ†è§£æˆå¯¹è§’çº¿å’Œæ‘„åŠ¨éƒ¨åˆ†ï¼š

![](pics/media/image365.png)

ç„¶åŽå°†æ‘„åŠ¨éƒ¨åˆ†å†™ä¸º$H_{1} + H_{2}$ï¼Œå› æ­¤$H = H_{0} + H_{0} + H_{2}$ï¼Œå…¶ä¸­$H_{0}$æ˜¯å¯¹è§’çŸ©é˜µã€$H_{0}$æ˜¯å—å¯¹è§’çŸ©é˜µã€$H_{2}$æ˜¯éžå—å¯¹è§’çŸ©é˜µï¼Œåˆ™ï¼š

![](pics/media/image366.png)

å¯ä»Žå—å¯¹è§’åŒ–$H$ä¸­æ‰¾å‡ºä¸€ä¸ªç®—ç¬¦$S$ï¼š

$$H_{\text{eff} } = e^{\text{iS} }He^{- iS} = \sum_{m = 0}^{\infty}{\frac{1}{m!}\lbrack H,S\rbrack^{(m)} } = \sum_{m = 0}^{\infty}{\lambda^{m}H^{(m)} }$$

å…¶ä¸­$H^{(m)}$æ˜¯$H$çš„é€æ¬¡é€¼è¿‘ï¼ˆ$H^{(0)} = H_{0}$ï¼‰ï¼Œå¹¿ä¹‰å¯¹æ˜“å¼è¢«é€’å½’åœ°å®šä¹‰ä¸ºï¼š

$$\lbrack H,S\rbrack^{\left( m \right)} = \lbrack\left\lbrack H,S\rbrack^{\left( m - 1 \right)},S \right\rbrack\text{\ \ \ \ }\text{with\ \ \ \ }\lbrack H,S\rbrack^{(0)} = H$$

æ­¤å¤„ï¼Œæˆ‘ä»¬å°†$S$æ˜¯ä¸ºä¸€ä¸ªæ³°å‹’çº§æ•°ï¼š

$$S = \sum_{m = 1}^{\infty}{\lambda^{m}S^{(m)} }$$

æ¥æŒç»­è·Ÿè¸ªé˜¶$\lambda$ã€‚ç„¶åŽå°†æœ‰æ•ˆçš„å“ˆå¯†é¡¿é‡ä½œä¸º$H_{1} + H_{2}$çš„æ‘„åŠ¨æ‰©å±•åˆ°$\lambda$ä¸­çš„ç¬¬äºŒé˜¶ï¼š

$$H_{\text{eff} } = H_{0} + \lambda(H_{1} + H_{2}) + \lbrack H_{0} + \lambda(H_{1} + H_{2}),\lambda S^{(1)}\rbrack + \frac{1}{2}\lbrack\lbrack H_{0} + \lambda(H_{1} + H_{2}),\lambda S^{(1)}\rbrack,\lambda S^{(1)}\rbrack + \lbrack H_{0} + \lambda(H_{1} + H_{2}),\lambda^{2}S^{(2)}\rbrack + \ldots \approx H_{0} + \lambda(H_{1} + H_{2} + \lbrack H_{0},S^{(1)}\rbrack) + \lambda^{2}(\lbrack H_{1} + H_{2},S^{(1)}\rbrack + \frac{1}{2}\lbrack\lbrack H_{0},S^{(1)},\rbrack S^{(1)}\rbrack + \lbrack H_{0},S^{(2)}\rbrack)$$

è‡³æ­¤ï¼Œæˆ‘ä»¬å¾—å‡º$S$å¿…ç„¶ä¸ºå—éžå¯¹è§’ï¼ˆblock
off-diagonalï¼‰ä»¥åŠæ–œåŸƒå°”ç±³ç‰¹çŸ©é˜µï¼Œè¿«ä½¿$H_{\text{eff} }$çš„å¯¹è§’çº¿å…ƒç´ æ¶ˆå¤±ã€‚å› æ­¤æˆ‘ä»¬å¾—å‡ºï¼š

$$H_{\text{eff} }^{\text{off} - \text{diag} } = \sum_{m = 0}^{\infty}{\frac{1}{\left( 2m + 1 \right)!}\lbrack\underset{\text{block\ diag} }{\overset{H_{0} + H_{1} }{ï¸¸} },S\rbrack^{\left( 2m + 1 \right)} } + \sum_{m = 0}^{\infty}{\frac{1}{\left( 2m \right)!}\lbrack\underset{\text{block\ off-diag} }{\overset{H_{2} }{ï¸¸} },S\rbrack^{\left( 2m \right)} } \equiv 0$$

å¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªçº§æ•°ä¸­çš„æ‰€æœ‰é¡¹å‡ä¸ºå—å¯¹è§’ï¼Œè€Œç¬¬äºŒä¸ªçº§æ•°ä¸­çš„æ‰€æœ‰é¡¹å‡ä¸ºå—éžå¯¹è§’çº¿ã€‚è¿™æ˜¯å› ä¸ºå—å¯¹è§’çŸ©é˜µå’Œå—éžå¯¹è§’çŸ©é˜µçš„å¯¹æ˜“å¼æ˜¯å—éžå¯¹è§’çŸ©é˜µï¼Œè€Œä¸¤ä¸ªå—éžå¯¹è§’çŸ©é˜µçš„å¯¹æ˜“å¼æ˜¯å—å¯¹è§’çŸ©é˜µã€‚å°†å…¶æ‰©å±•åˆ°å¹¿ä¹‰å¯¹æ˜“å¼åŽï¼Œæˆ‘ä»¬å°±å¯ä»¥çœ‹åˆ°nä¸ºå¥‡æ•°æ—¶$\lbrack H^{0} + H^{1},S\rbrack^{(n)}$å¿…ä¸ºå—éžå¯¹è§’çŸ©é˜µï¼Œnä¸ºå¶æ•°æ—¶$\lbrack H^{2},S\rbrack^{(n)}$å¿…ä¸ºå—å¯¹è§’çŸ©é˜µã€‚çŽ°åœ¨å°†å“ˆå¯†é¡¿é‡çš„éžå¯¹è§’éƒ¨åˆ†æ‰©å±•è‡³å…¶äºŒé˜¶å­å¼ï¼š

$$H_{\text{eff} }^{\text{off} - \text{diag} } = \lbrack H_{0} + \lambda H_{1},\lambda S^{(1)}\rbrack + \lambda H_{2} + \lbrack H_{0} + \lambda H_{1},\lambda^{2}S^{(2)}\rbrack + \frac{1}{3!}{\lbrack H_{0} + \lambda H_{1},\lambda S^{(1)}\rbrack}^{(3)} + \frac{1}{2!}{\lbrack\lambda H_{2},\lambda S^{(1)}\rbrack}^{(2)} = \lambda(\lbrack H_{0},S^{(1)}\rbrack + H_{2}) + \lambda^{2}(\lbrack H_{1},S^{(1)}\rbrack + \lbrack H_{0},S^{(2)}\rbrack) + \ldots$$

ç”±äºŽ$\lambda$çš„æ¯ä¸€é˜¶å¿…ç„¶ç­‰äºŽé›¶ï¼Œå› æ­¤ä»¥ä¸‹å¼ç¡®å®š$S(m)$ï¼š

$$\lbrack H_{0},S^{(1)}\rbrack = - H_{2}\lbrack H_{0},S^{(2)}\rbrack = - \lbrack H_{1},S^{(1)}\rbrack\lbrack H_{0},S^{(3)}\rbrack = - \lbrack H_{1},S^{(2)}\rbrack - \frac{1}{3}\lbrack\lbrack H_{2},S^{(1)}\rbrack,S^{(1)}\rbrack$$

å…¶ä¸­æˆ‘ä»¬çš„æ‹Ÿè®¾ä¸ºé€šè¿‡Winklerçš„å·¥ä½œä¿è¯è¿™äº›ç­‰å¼å”¯ä¸€ã€‚åˆ™æœ‰æ•ˆå“ˆå¯†é¡¿é‡å˜ä¸ºï¼š

$$H_{\text{eff} } = H_{0} + H_{1} + \lbrack H_{2},S^{(1)}\rbrack + \frac{1}{2}\lbrack\lbrack H_{0},S^{(1)}\rbrack,S^{(1)}\rbrack + \ldots = H_{0} + H_{1} + \frac{1}{2}\lbrack H_{2},S^{(1)}\rbrack + \ldots$$

æ­¤å¤„çš„æœ‰æ•ˆå“ˆå¯†é¡¿é‡æ˜¯å–$\lambda \rightarrow 1$çš„ç¬¬äºŒé˜¶ã€‚

### 3. Jaynes-Cummingså“ˆå¯†é¡¿é‡çš„å—å¯¹è§’åŒ–

ä½¿ç”¨S-Wå˜æ¢ä¼šå¸¦å…¥ä¸¤ä¸ªé—®é¢˜ï¼š

1.  æ‰¾å‡ºæ­£ç¡®çš„æ‹Ÿè®¾ï¼›

2.  æ‰§è¡Œè®¡ç®—ã€‚

åœ¨å¤§éƒ¨åˆ†çš„ç¤ºä¾‹ä¸­ï¼Œæ‹Ÿè®¾ç±»ä¼¼äºŽç”Ÿæˆéžå¯¹è§’éƒ¨åˆ†ä»¥åŠç¡®è®¤å…¶ä¸ºå”¯ä¸€ï¼ˆ$\text{postori}$ï¼‰ã€‚æœ€è¿‘ï¼ŒarXivä¸Šå‡ºçŽ°äº†åä¸ºã€ŠSchrieffer-Wolffå˜æ¢çš„ç³»ç»Ÿæ–¹æ³•åŠå…¶æ¦‚æ‹¬ã€‹çš„æ–‡ç« ï¼Œå…¶ä¸­ç³»ç»Ÿåœ°ç»™å‡ºäº†æ‹Ÿè®¾å¹¶å°†å…¶åº”ç”¨äºŽå¤§éƒ¨åˆ†ç³»ç»Ÿï¼ˆåŒ…æ‹¬ä¸‹é¢çš„Jaynes-Cumming
Hamiltonianï¼‰ã€‚

è¯¸å¦‚ï¼Œç”Ÿæˆå™¨$\eta = \lbrack H_{0},H_{2}\rbrack$ã€‚åœ¨ä¸ç¡®å®š$\eta$çš„æ ‡é‡ç³»æ•°çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥å°†$S^{(1)}$è®¡ç®—ä¸ºæ»¡è¶³$\lbrack H_{0},\eta\rbrack = H_{2}$çš„ç‰¹å®š$\eta$ã€‚å› è€Œ$H_{0}$å’Œ$H_{2}$çš„åŽ„ç±³æ€§ï¼ˆhermiticityï¼‰ä¿è¯äº†$\eta$çš„éžåŽ„ç±³æ€§ï¼ˆanti-hermiticityï¼‰ï¼Œä»Žè€Œä¿è¯äº†$S^{(1)}$çš„éžåŽ„ç±³æ€§ã€‚

ä¸ºäº†ç®€åŒ–ç¹ççš„è®¡ç®—ï¼Œæˆ‘ä»¬å°†ä¼šç”¨åˆ°Pythonè½¯ä»¶åŒ…sympyè¿›è¡Œç¬¦å·è¿ç®—ã€‚

> \# import SymPy and define symbols
>
> import sympy as sp
>
> sp.init_printing(use_unicode=True)
>
> wr = sp.Symbol(\'\\omega_r\') \# resonator frequency
>
> wq = sp.Symbol(\'\\omega_q\') \# qubit frequency
>
> g = sp.Symbol(\'g\', real=True) \# vacuum Rabi coupling
>
> Delta = sp.Symbol(\'Delta\', real=True) \# wr - wq; defined later
>
> \# import operator relations and define them
>
> from sympy.physics.quantum.boson import BosonOp
>
> a = BosonOp(\'a\') \# resonator photon annihilation operator
>
> from sympy.physics.quantum import pauli, Dagger, Commutator
>
> from sympy.physics.quantum.operatorordering import normal_ordered_form
>
> \# Pauli matrices
>
> sx = pauli.SigmaX()
>
> sy = pauli.SigmaY()
>
> sz = pauli.SigmaZ()
>
> \# qubit raising and lowering operators
>
> splus = pauli.SigmaPlus()
>
> sminus = pauli.SigmaMinus()
>
> \# define J-C Hamiltonian in terms of diagonal and non-block diagonal
> terms
>
> H0 = wr\*Dagger(a)\*a - (1/2)\*wq\*sz;
>
> H2 = g\*(Dagger(a)\*sminus + a\*splus);
>
> HJC = H0 + H2; HJC \# print
>
> è¾“å‡ºï¼š

$$- 0.5\omega_{q}\sigma_{z} + \omega_{r}a^{\dagger}a + g(a^{\dagger}\sigma_{-} + a\sigma_{+})$$

> \# using the above method for finding the ansatz
>
> eta = Commutator(H0, H2); eta
>
> è¾“å‡ºï¼š

$$- g\lbrack a^{\dagger}\sigma_{-} + a\sigma_{+}, - 0.5\omega_{q}\sigma_{z} + \omega_{r}a^{\dagger}a\rbrack$$

ä½œä¸ºå¯¹äºŽsympyçš„è¯´æ˜Žï¼Œæˆ‘ä»¬å°†ä¼šä½¿ç”¨æ–¹æ³•doit()ã€expandã€normal_ordered_formä»¥åŠqsimplify_pauliæ¥å®žé™…æ‰§è¡Œå¯¹æ˜“å¼ï¼Œå°†å…¶å±•å¼€è‡³å„ä¸ªé¡¹ä¸­ï¼Œå¯¹çŽ»è‰²å­æ¨¡å¼è¿›è¡Œæ­£å¸¸æŽ’åºï¼ˆåœ¨æ¹®æ²¡ä¹‹å‰äº§ç”Ÿï¼‰ï¼Œå¹¶ç®€åŒ–Pauliä»£æ•°ã€‚å°è¯•ç”¨$\eta$ç”Ÿæˆï¼š

> pauli.qsimplify_pauli(normal_ordered_form(eta.doit().expand()))
>
> è¾“å‡ºï¼š

$$1.0\omega_{q}ga^{\dagger}\sigma_{-} - 1.0\omega_{q}\text{ga}\sigma_{+} + \omega_{r}ga^{\dagger}\sigma_{-} - \omega_{r}\text{ga}\sigma_{+}$$

åˆ†åˆ«ä»¥$A$å’Œ$B$ä½œä¸º$a^{\dagger}\sigma_{-}$å’Œ$a\sigma_{+}$çš„ç³»æ•°ï¼Œåˆ™å¯¹æ˜“å¼å°†å˜ä¸ºï¼š

> A = sp.Symbol(\'A\')
>
> B = sp.Symbol(\'B\')
>
> eta = A \* Dagger(a) \* sminus - B \* a \* splus;
>
> pauli.qsimplify_pauli(normal_ordered_form(Commutator(H0,
> eta).doit().expand()))
>
> è¾“å‡ºï¼š

$$1.0A\omega_{q}a^{\dagger}\sigma_{-} + A\omega_{r}a^{\dagger}\sigma_{-} + 1.0B\omega_{q}a\sigma_{+} + B\omega_{r}a\sigma_{+}$$

è¯¥è¡¨è¾¾å¼åº”ç­‰äºŽ$H_{2}$ï¼š

> H2
>
> è¾“å‡ºï¼š

$$g(a^{\dagger}\sigma_{-} + a\sigma_{+})$$

è¡¨æ˜Ž$A = B = g/\Delta$ï¼Œå…¶ä¸­$\Delta = \omega_{r} - \omega_{q}$æ˜¯è°æŒ¯å™¨å’Œé‡å­æ¯”ç‰¹é—´çš„é¢‘çŽ‡å¤±è°ã€‚å› æ­¤$S^{(1)}$è¢«ç¡®å®šä¸ºï¼š

> S1 = eta.subs(A, g/Delta)
>
> S1 = S1.subs(B, g/Delta); S1.factor()
>
> è¾“å‡ºï¼š

$$\frac{g(a^{\dagger}\sigma_{-} - a\sigma_{+})}{\Delta}$$

ç„¶åŽå°±å¯ä»¥è®¡ç®—å‡ºå¯¹$H_{0}$çš„æœ‰æ•ˆäºŒé˜¶æ ¡æ­£ï¼š

> Heff = H0 +
> 0.5\*pauli.qsimplify_pauli(normal_ordered_form(Commutator(H2,
> S1).doit().expand())).simplify(); Heff
>
> è¾“å‡ºï¼š

$$- 0.5\omega_{q}\sigma_{z} + \omega_{r}a^{\dagger}a + \frac{0.5g^{2}(1 + 2a^{\dagger}a\sigma_{z} + \sigma_{z})}{\Delta}$$

ä¸Šå¼é€šå¸¸å†™æˆï¼š

$$H_{\text{eff} } = (\omega_{r} + \frac{g^{2} }{\Delta}\sigma_{z})a^{\dagger}a - \frac{1}{2}(\omega_{q} - \frac{g^{2} }{\Delta})\sigma_{z}$$

æ˜¾ç¤ºäº†è°æŒ¯å™¨é¢‘çŽ‡$x \equiv g^{2}/\Delta$çš„çŠ¶æ€ä¾èµ–ç§»ä½ï¼ˆstate-dependent
shiftï¼‰ï¼Œç§°ä¸ºac Stark
shiftã€‚ä»¥åŠç”±äºŽé‡å­çœŸç©ºæ³¢åŠ¨è€Œå¼•èµ·çš„é‡å­æ¯”ç‰¹é¢‘çŽ‡çš„ç§»ä½ï¼Œç§°ä¸ºLambç§»ä½ï¼ˆLamb
shiftï¼‰ã€‚

### 4. å…¨Transmon

ç”±äºŽæˆ‘ä»¬ç”¨transmonä»£æ›¿äº†é‡å­æ¯”ç‰¹ï¼Œæ‰€ä»¥åœ¨è®¾è®¡å’Œæ¨¡æ‹Ÿè®¾å¤‡æ—¶éœ€è¦éžå¸¸å°å¿ƒåœ°å¤„ç†é«˜é˜¶èƒ½çº§é¡¹å¸¦å…¥çš„å½±å“ã€‚è€¦åˆè‡³è¯»å–è°æŒ¯å™¨çš„å…¨Transmonå“ˆå¯†é¡¿é‡ä¸ºï¼š

$$H^{\text{tr} } = \omega_{r}a^{\dagger}a + \sum_{j}^{}{\omega_{j}|j\rangle\langle j| + g(a^{\dagger}c + ac^{\dagger})}$$

å…¶ä¸­æ­¤å¤„çš„$c = \sum_{j}^{}{\sqrt{j + 1}|j\rangle\langle j + 1|}$ä¸ºtransmonä¸‹é™ç®—ç¬¦ã€‚åŒæ ·ï¼Œå°†å¼±ä½œç”¨å­é›†$A$ä½œä¸ºå¶æ•°transmonæ¨¡å¼ï¼Œå°†$B$ä½œä¸ºå¥‡æ•°transmonæ¨¡å¼ã€‚é‡‡ç”¨æ‹Ÿè®¾ï¼š

$$S^{(1)} = \sum_{j}^{}{\alpha_{j}a^{\dagger}\sqrt{j + 1}|j\rangle\langle j + 1| - \alpha_{j}^{*}a\sqrt{j + 1}|j + 1\rangle\langle j|}$$

æœ‰äººèƒ½ä¼šæ²¿ç”¨Jaynes-Cummingså“ˆå¯†é¡¿é‡çš„æ‚ä¹±ç‰ˆæœ¬ã€‚é€šè¿‡ä¸€äº›åŠªåŠ›ï¼Œå¯ä»¥è¯æ˜ŽäºŒé˜¶æœ‰æ•ˆå“ˆå¯†é¡¿é‡ä¸ºï¼š

$$H_{\text{eff} }^{\text{tr} } = (\omega_{r} + \sum_{j}^{}{\frac{g^{2}(\omega_{r} - \omega + \delta)}{(\omega_{r} - \omega - \delta j)(\omega_{r} - \omega - \delta(j - 1))}|j\rangle\langle j|)a^{\dagger}a} + \sum_{j}^{}{\lbrack j\omega + \frac{\delta}{2}(j - 1)j + \frac{jg^{2} }{\omega - \omega_{r} + (j - 1)\delta}\rbrack}|j\rangle\langle j|$$

### 5. å…·æœ‰cQEDçš„Qubité©±åŠ¨

ä¾æ®Blaisç­‰äººäºŽ2004å‘è¡¨çš„[æ–‡ç« ](https://arxiv.org/pdf/cond-mat/0402216.pdf)ï¼Œæˆ‘ä»¬å°†é©±åŠ¨çš„å“ˆå¯†é¡¿é‡å»ºæ¨¡ä¸ºï¼š

$$H^{d}(t) = \xi(t)(a^{\dagger}e^{- i\omega_{d}t} + ae^{i\omega_{d}t})$$

ä¾æ®Lev
Bishopåšå£«[è®ºæ–‡](https://arxiv.org/ftp/arxiv/papers/1007/1007.3520.pdf)ä¸­çš„å¤„ç†æ–¹æ³•ï¼Œé©±åŠ¨é€šè¿‡Glauberç®—ç¬¦ä½œç”¨äºŽé‡å­æ¯”ç‰¹ï¼š

$$D(\alpha) = e^{\alpha(t)a^{\dagger} - \alpha^{*}(t)a}$$

æˆ‘ä»¬æ¥çœ‹çœ‹åœ¨é©±åŠ¨é¢‘çŽ‡ä¸‹æ—‹è½¬çš„Jaynes-Cummingå“ˆå¯†é¡¿é‡ï¼š

$$H = \Delta_{r}a^{\dagger}a - \frac{1}{2}\Delta_{q}\sigma^{z} + g(a^{\dagger}\sigma^{-} + a\sigma^{+}) + \xi(t)(a^{\dagger} + a)$$

å…¶ä¸­$\Delta_{r} = \omega_{r} - \omega_{d}$ï¼Œ$\Delta_{q} = \omega_{q} - \omega_{d}$ã€‚å°†é˜¿è¾¾çŽ›å¼•ç†åº”ç”¨äºŽåµŒå¥—å¯¹æ˜“å¼ï¼š

$$e^{A}BA^{- A} = B + \lbrack A,B\rbrack + \frac{1}{2!}\lbrack A,\lbrack A,B\rbrack\rbrack + \frac{1}{3!}\lbrack A,\lbrack A,\lbrack A,B\rbrack\rbrack\rbrack + \ldots$$

æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼š

$$D^{\dagger}a^{( \dagger )}D = \exp\{ - \alpha(t)a^{\dagger} + \alpha^{*}(t)a\} a^{( \dagger )}\exp\{\alpha(t)a^{\dagger} - \alpha^{*}(t)a\} = a^{( \dagger )} + \lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{( \dagger )}\rbrack + \frac{1}{2!}\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{( \dagger )}\rbrack\rbrack + \ldots = a^{( \dagger )} + \alpha^{(*)}$$

ä»¥åŠï¼š

$$D^{\dagger}a^{\dagger}aD = a^{\dagger}a + \lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{\dagger}a\rbrack + \frac{1}{2!}\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,\lbrack - \alpha(t)a^{\dagger} + \alpha^{*}(t)a,a^{\dagger}a\rbrack\rbrack + \ldots = a^{\dagger}a + \alpha(t)a^{\dagger} + \alpha^{*}(t)a + |\alpha(t)|^{2}$$

å› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸€å“ˆå¯†é¡¿é‡å˜æ¢ä¸ºï¼š

$$\overset{\sim}{H} = D^{\dagger}HD - iD^{\dagger}\overset{Ë™}{D} = \Delta_{r}(a^{\dagger}a + \alpha(t)a^{\dagger} + \alpha^{*}(t)a + |\alpha(t)|^{2}) - \frac{1}{2}\Delta_{q}\sigma^{z} + g((a^{\dagger} + \alpha^{*}(t))\sigma^{-} + (a + \alpha(t))\sigma^{+}) + \xi(t)(a^{\dagger} + \alpha^{*}(t) + a + \alpha(t)) - i(\overset{Ë™}{\alpha}(t)a^{\dagger} - {\overset{Ë™}{\alpha} }^{*}(t)a) = \Delta_{r}a^{\dagger}a - \frac{1}{2}\Delta_{q}\sigma^{z} + g((a^{\dagger} + \alpha^{*}(t))\sigma^{-} + (a + \alpha(t))\sigma^{+}) + \xi(t)(a^{\dagger} + a) + \Delta_{r}(\alpha(t)a^{\dagger} + \alpha^{*}(t)a) - i(\overset{Ë™}{\alpha}(t)a^{\dagger} - {\overset{Ë™}{\alpha} }^{*}(t)a)$$

åŽ»æŽ‰äº†éžç®—ç¬¦é¡¹ã€‚æœ€åŽä¸€è¡Œå¯ä»¥è®¾ç½®ä¸ºé›¶ï¼Œå¦‚ï¼š

$$- i\overset{Ë™}{\alpha}(t) + \Delta_{r}\alpha(t) + \xi(t) = 0$$

å¼•å…¥Rabié¢‘çŽ‡$\Omega(t) = 2g\alpha(t)$åŽå¾—åˆ°ï¼š

$$\overset{\sim}{H} = \Delta_{r}a^{\dagger}a - \frac{1}{2}\Delta_{q}\sigma^{z} + g(a^{\dagger}\sigma^{-} + a\sigma^{+}) + \frac{1}{2}(\Omega^{*}(t)\sigma^{-} + \Omega(t)\sigma^{+})$$

ç”±äºŽå“ˆå¯†é¡¿é‡çš„é©±åŠ¨éƒ¨åˆ†æ˜¯å—éžå¯¹è§’çº¿çŸ©é˜µï¼Œå› æ­¤å¯¹äºŽçœŸå®žé©±åŠ¨$\Omega^{*}(t) = \Omega(t)$æˆ‘ä»¬å¯ä»¥å¯¹å…¶è¿›è¡ŒSchrieffer-Wolffå˜æ¢ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°æœ‰æ•ˆå“ˆå¯†é¡¿é‡ä¸­ï¼š

$$\lbrack{\overset{\sim}{H} }^{d},S^{(1)}\rbrack = - \frac{\Omega(t)}{2}\lbrack(\sigma^{-} + \sigma^{+}),\frac{g}{\Delta}(a^{\dagger}\sigma^{-} - a\sigma^{+})\rbrack = \frac{g\Omega(t)}{2\Delta}(a + a^{\dagger})\sigma^{z}$$

å› è€Œï¼Œæœ‰æ•ˆå“ˆå¯†é¡¿é‡å°±å˜ä¸ºï¼š

$${\overset{\sim}{H} }_{\text{eff} } = (\Delta_{r} + \frac{g^{2} }{\Delta}\sigma^{z})a^{\dagger}a - \frac{1}{2}(\Delta_{q} - \frac{g^{2} }{\Delta})\sigma^{z} + \frac{\Omega(t)}{2}\sigma^{x} + \frac{g\Omega(t)}{4\Delta}(a + a^{\dagger})\sigma^{z}$$

æ­¤å¤„å¯ä»¥çœ‹åˆ°è‹¥è¦æ¶ˆé™¤$z$æ—‹è½¬ï¼Œéœ€è¦åœ¨ç»Lambç§»ä½ï¼ˆLamb-shiftedï¼‰çš„é‡å­æ¯”ç‰¹é¢‘çŽ‡ä¸Šæ–½åŠ é©±åŠ¨ã€‚ç”±äºŽåœ¨é¢‘æ•£çŠ¶å†µä¸‹$\Delta \gg g$ï¼Œé™„åŠ é¡¹$\sigma^{z}$å¾ˆå°ã€‚

### 6. äº¤å‰è°æŒ¯çº ç¼ é‡å­é—¨

ä»¥é‡å­æ€æ¯”ç‰¹2çš„é¢‘çŽ‡é©±åŠ¨é‡å­æ¯”1å¯ä»¥å†™æˆï¼š

$$H^{d}(t) = \frac{\Omega(t)}{2}(\sigma_{1}^{+}e^{- i{\overset{\sim}{\omega} }_{2}t} + \sigma_{1}^{-}e^{i{\overset{\sim}{\omega} }_{2}t}).$$

çŽ°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦å°†Schrieffer-Wolffæ–½åŠ åœ¨é©±åŠ¨é¡¹ä¸Šæ¥èŽ·å¾—æœ‰æ•ˆçš„å“ˆå¯†é¡¿é‡ï¼Œç„¶åŽåœ¨é¢‘çŽ‡${\overset{\sim}{\omega} }_{2}$å¤„è¿›è¡ŒRWAï¼ˆæ—‹è½¬æ³¢è¿‘ä¼¼
Rotating Wave Approximationï¼‰ã€‚

$$\lbrack{\overset{\sim}{H} }^{d},S^{(1)}\rbrack = - \frac{J\Omega(t)}{2\Delta_{12} }\lbrack\sigma_{1}^{+}e^{- i{\overset{\sim}{\omega} }_{2}t} + \sigma_{1}^{-}e^{i{\overset{\sim}{\omega} }_{2}t},\sigma_{1}^{+}\sigma_{2}^{-} - \sigma_{2}^{+}\sigma_{1}^{-}\rbrack = - \frac{J\Omega(t)}{2\Delta_{12} }(\sigma_{1}^{z}\sigma_{2}^{+}e^{- i{\overset{\sim}{\omega} }_{2}t} + \sigma_{1}^{z}\sigma_{2}^{-}e^{i{\overset{\sim}{\omega} }_{2}t})$$

é€šè¿‡åœ¨$\omega_{2}$å‡ºå˜æ¢ä¼šæ—‹è½¬å¸§ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°æœ‰æ•ˆçš„é‡å­æ¯”ç‰¹äº¤å‰è°æŒ¯å“ˆå¯†é¡¿é‡ï¼š

$${\overset{\sim}{H} }_{\text{eff} }^{\text{CR} } = - \frac{ {\overset{\sim}{\omega} }_{1} - {\overset{\sim}{\omega} }_{2} }{2}\sigma_{1}^{z} + \frac{\Omega(t)}{2}(\sigma_{2}^{x} - \frac{J}{2\Delta_{12} }\sigma_{1}^{z}\sigma_{2}^{x}).$$

å‰ä¸¤é¡¹æ¶‰åŠç”±äºŽé‡å­æ¯”ç‰¹1ä¸Šçš„Starkç§»ä½å’Œé‡å­æ¯”ç‰¹2ä¸Šçš„æ— æ¡ä»¶$\text{IX}$æ—‹è½¬è€Œå¼•èµ·çš„$\text{ZI}$äº¤äº’ï¼Œä½†æ˜¯æœ€åŽä¸€é¡¹å‘ˆçŽ°äº†äº§ç”Ÿçº ç¼ çš„$\text{ZX}$-äº¤äº’ã€‚é€šè¿‡å°†é‡å­æ¯”ç‰¹1ç½®äºŽ$|0\rangle$å’Œ$|1\rangle$çš„ç­‰åŒå åŠ ï¼Œå¹¶åœ¨ä¸Žç»•$x$è½´è¿›è¡Œ$\pi/2$æ—‹è½¬ç›¸å¯¹åº”çš„æŒç»­æ—¶é—´å†…æ–½åŠ äº¤å‰è°æŒ¯é—¨ï¼Œä¾¿äº§ç”Ÿäº†æœ€å¤§çš„çº ç¼ æ€ã€‚ç”¨Qiskitè¡¨å¾transmonçš„åŒé‡å­æ¯”ç‰¹äº¤å‰è°æŒ¯å“ˆå¯†é¡¿é‡çš„è¿‡ç¨‹å¯åœ¨[Github](https://github.com/Qiskit/qiskit-tutorials/blob/9405254b38312771f8d5c2dd6f451cec35307995/tutorials/noise/1_hamiltonian_and_gate_characterization.ipynb)ä¸Šæ‰¾åˆ°ã€‚å…³äºŽäº¤å‰è°æŒ¯é‡å­é—¨çš„è¡¥å……é˜…è¯»èµ„æ–™ï¼š

1\. [A simple all-microwave entangling gate for fixed-frequency
superconducting qubits](https://arxiv.org/abs/1106.0553)

2\. [Procedure for systematically tuning up crosstalk in the cross
resonance gate](https://arxiv.org/abs/1603.04821)